// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_INPUTACTION_GAMIUM_PROTOCOL_PACKETS_ACTIONS_H_
#define FLATBUFFERS_GENERATED_INPUTACTION_GAMIUM_PROTOCOL_PACKETS_ACTIONS_H_

#include "flatbuffers/flatbuffers.h"

// Ensure the included flatbuffers.h is the same version as when this file was
// generated, otherwise it may not be compatible.
static_assert(FLATBUFFERS_VERSION_MAJOR == 22 &&
              FLATBUFFERS_VERSION_MINOR == 10 &&
              FLATBUFFERS_VERSION_REVISION == 26,
             "Non-compatible flatbuffers version included");

#include "input_generated.h"
#include "object_generated.h"
#include "vector_generated.h"

namespace Gamium {
namespace Protocol {
namespace Packets {
namespace Actions {

struct InputKeyParam;
struct InputKeyParamBuilder;
struct InputKeyParamT;

struct InputMouseParam;
struct InputMouseParamBuilder;
struct InputMouseParamT;

struct InputSetTextParam;
struct InputSetTextParamBuilder;
struct InputSetTextParamT;

inline const flatbuffers::TypeTable *InputKeyParamTypeTable();

inline const flatbuffers::TypeTable *InputMouseParamTypeTable();

inline const flatbuffers::TypeTable *InputSetTextParamTypeTable();

struct InputKeyParamT : public flatbuffers::NativeTable {
  typedef InputKeyParam TableType;
  Gamium::Protocol::Types::InputKeyPressType press = Gamium::Protocol::Types::InputKeyPressType::DOWN;
  std::vector<std::string> codes{};
};

struct InputKeyParam FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef InputKeyParamT NativeTableType;
  typedef InputKeyParamBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return InputKeyParamTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_PRESS = 4,
    VT_CODES = 6
  };
  Gamium::Protocol::Types::InputKeyPressType press() const {
    return static_cast<Gamium::Protocol::Types::InputKeyPressType>(GetField<int16_t>(VT_PRESS, 0));
  }
  const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *codes() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *>(VT_CODES);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int16_t>(verifier, VT_PRESS, 2) &&
           VerifyOffset(verifier, VT_CODES) &&
           verifier.VerifyVector(codes()) &&
           verifier.VerifyVectorOfStrings(codes()) &&
           verifier.EndTable();
  }
  InputKeyParamT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(InputKeyParamT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<InputKeyParam> Pack(flatbuffers::FlatBufferBuilder &_fbb, const InputKeyParamT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct InputKeyParamBuilder {
  typedef InputKeyParam Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_press(Gamium::Protocol::Types::InputKeyPressType press) {
    fbb_.AddElement<int16_t>(InputKeyParam::VT_PRESS, static_cast<int16_t>(press), 0);
  }
  void add_codes(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> codes) {
    fbb_.AddOffset(InputKeyParam::VT_CODES, codes);
  }
  explicit InputKeyParamBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<InputKeyParam> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<InputKeyParam>(end);
    return o;
  }
};

inline flatbuffers::Offset<InputKeyParam> CreateInputKeyParam(
    flatbuffers::FlatBufferBuilder &_fbb,
    Gamium::Protocol::Types::InputKeyPressType press = Gamium::Protocol::Types::InputKeyPressType::DOWN,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> codes = 0) {
  InputKeyParamBuilder builder_(_fbb);
  builder_.add_codes(codes);
  builder_.add_press(press);
  return builder_.Finish();
}

flatbuffers::Offset<InputKeyParam> CreateInputKeyParam(flatbuffers::FlatBufferBuilder &_fbb, const InputKeyParamT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct InputMouseParamT : public flatbuffers::NativeTable {
  typedef InputMouseParam TableType;
  Gamium::Protocol::Types::InputMousePressType press = Gamium::Protocol::Types::InputMousePressType::DOWN;
  Gamium::Protocol::Types::InputMouseButtonCode button = Gamium::Protocol::Types::InputMouseButtonCode::LEFT;
  Gamium::Protocol::Types::Vector2 position{};
  Gamium::Protocol::Types::Vector2 delta{};
};

struct InputMouseParam FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef InputMouseParamT NativeTableType;
  typedef InputMouseParamBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return InputMouseParamTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_PRESS = 4,
    VT_BUTTON = 6,
    VT_POSITION = 8,
    VT_DELTA = 10
  };
  Gamium::Protocol::Types::InputMousePressType press() const {
    return static_cast<Gamium::Protocol::Types::InputMousePressType>(GetField<int16_t>(VT_PRESS, 0));
  }
  Gamium::Protocol::Types::InputMouseButtonCode button() const {
    return static_cast<Gamium::Protocol::Types::InputMouseButtonCode>(GetField<int16_t>(VT_BUTTON, 0));
  }
  const Gamium::Protocol::Types::Vector2 *position() const {
    return GetStruct<const Gamium::Protocol::Types::Vector2 *>(VT_POSITION);
  }
  const Gamium::Protocol::Types::Vector2 *delta() const {
    return GetStruct<const Gamium::Protocol::Types::Vector2 *>(VT_DELTA);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int16_t>(verifier, VT_PRESS, 2) &&
           VerifyField<int16_t>(verifier, VT_BUTTON, 2) &&
           VerifyField<Gamium::Protocol::Types::Vector2>(verifier, VT_POSITION, 4) &&
           VerifyField<Gamium::Protocol::Types::Vector2>(verifier, VT_DELTA, 4) &&
           verifier.EndTable();
  }
  InputMouseParamT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(InputMouseParamT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<InputMouseParam> Pack(flatbuffers::FlatBufferBuilder &_fbb, const InputMouseParamT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct InputMouseParamBuilder {
  typedef InputMouseParam Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_press(Gamium::Protocol::Types::InputMousePressType press) {
    fbb_.AddElement<int16_t>(InputMouseParam::VT_PRESS, static_cast<int16_t>(press), 0);
  }
  void add_button(Gamium::Protocol::Types::InputMouseButtonCode button) {
    fbb_.AddElement<int16_t>(InputMouseParam::VT_BUTTON, static_cast<int16_t>(button), 0);
  }
  void add_position(const Gamium::Protocol::Types::Vector2 *position) {
    fbb_.AddStruct(InputMouseParam::VT_POSITION, position);
  }
  void add_delta(const Gamium::Protocol::Types::Vector2 *delta) {
    fbb_.AddStruct(InputMouseParam::VT_DELTA, delta);
  }
  explicit InputMouseParamBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<InputMouseParam> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<InputMouseParam>(end);
    return o;
  }
};

inline flatbuffers::Offset<InputMouseParam> CreateInputMouseParam(
    flatbuffers::FlatBufferBuilder &_fbb,
    Gamium::Protocol::Types::InputMousePressType press = Gamium::Protocol::Types::InputMousePressType::DOWN,
    Gamium::Protocol::Types::InputMouseButtonCode button = Gamium::Protocol::Types::InputMouseButtonCode::LEFT,
    const Gamium::Protocol::Types::Vector2 *position = nullptr,
    const Gamium::Protocol::Types::Vector2 *delta = nullptr) {
  InputMouseParamBuilder builder_(_fbb);
  builder_.add_delta(delta);
  builder_.add_position(position);
  builder_.add_button(button);
  builder_.add_press(press);
  return builder_.Finish();
}

flatbuffers::Offset<InputMouseParam> CreateInputMouseParam(flatbuffers::FlatBufferBuilder &_fbb, const InputMouseParamT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct InputSetTextParamT : public flatbuffers::NativeTable {
  typedef InputSetTextParam TableType;
  std::string object_id{};
  std::string text{};
};

struct InputSetTextParam FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef InputSetTextParamT NativeTableType;
  typedef InputSetTextParamBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return InputSetTextParamTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_OBJECT_ID = 4,
    VT_TEXT = 6
  };
  const flatbuffers::String *object_id() const {
    return GetPointer<const flatbuffers::String *>(VT_OBJECT_ID);
  }
  const flatbuffers::String *text() const {
    return GetPointer<const flatbuffers::String *>(VT_TEXT);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_OBJECT_ID) &&
           verifier.VerifyString(object_id()) &&
           VerifyOffset(verifier, VT_TEXT) &&
           verifier.VerifyString(text()) &&
           verifier.EndTable();
  }
  InputSetTextParamT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(InputSetTextParamT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<InputSetTextParam> Pack(flatbuffers::FlatBufferBuilder &_fbb, const InputSetTextParamT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct InputSetTextParamBuilder {
  typedef InputSetTextParam Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_object_id(flatbuffers::Offset<flatbuffers::String> object_id) {
    fbb_.AddOffset(InputSetTextParam::VT_OBJECT_ID, object_id);
  }
  void add_text(flatbuffers::Offset<flatbuffers::String> text) {
    fbb_.AddOffset(InputSetTextParam::VT_TEXT, text);
  }
  explicit InputSetTextParamBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<InputSetTextParam> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<InputSetTextParam>(end);
    return o;
  }
};

inline flatbuffers::Offset<InputSetTextParam> CreateInputSetTextParam(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> object_id = 0,
    flatbuffers::Offset<flatbuffers::String> text = 0) {
  InputSetTextParamBuilder builder_(_fbb);
  builder_.add_text(text);
  builder_.add_object_id(object_id);
  return builder_.Finish();
}

flatbuffers::Offset<InputSetTextParam> CreateInputSetTextParam(flatbuffers::FlatBufferBuilder &_fbb, const InputSetTextParamT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

inline InputKeyParamT *InputKeyParam::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<InputKeyParamT>(new InputKeyParamT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void InputKeyParam::UnPackTo(InputKeyParamT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = press(); _o->press = _e; }
  { auto _e = codes(); if (_e) { _o->codes.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->codes[_i] = _e->Get(_i)->str(); } } else { _o->codes.resize(0); } }
}

inline flatbuffers::Offset<InputKeyParam> InputKeyParam::Pack(flatbuffers::FlatBufferBuilder &_fbb, const InputKeyParamT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateInputKeyParam(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<InputKeyParam> CreateInputKeyParam(flatbuffers::FlatBufferBuilder &_fbb, const InputKeyParamT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const InputKeyParamT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _press = _o->press;
  auto _codes = _fbb.CreateVectorOfStrings(_o->codes);
  return Gamium::Protocol::Packets::Actions::CreateInputKeyParam(
      _fbb,
      _press,
      _codes);
}

inline InputMouseParamT *InputMouseParam::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<InputMouseParamT>(new InputMouseParamT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void InputMouseParam::UnPackTo(InputMouseParamT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = press(); _o->press = _e; }
  { auto _e = button(); _o->button = _e; }
  { auto _e = position(); if (_e) _o->position = *_e; }
  { auto _e = delta(); if (_e) _o->delta = *_e; }
}

inline flatbuffers::Offset<InputMouseParam> InputMouseParam::Pack(flatbuffers::FlatBufferBuilder &_fbb, const InputMouseParamT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateInputMouseParam(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<InputMouseParam> CreateInputMouseParam(flatbuffers::FlatBufferBuilder &_fbb, const InputMouseParamT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const InputMouseParamT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _press = _o->press;
  auto _button = _o->button;
  auto _position = &_o->position;
  auto _delta = &_o->delta;
  return Gamium::Protocol::Packets::Actions::CreateInputMouseParam(
      _fbb,
      _press,
      _button,
      _position,
      _delta);
}

inline InputSetTextParamT *InputSetTextParam::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<InputSetTextParamT>(new InputSetTextParamT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void InputSetTextParam::UnPackTo(InputSetTextParamT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = object_id(); if (_e) _o->object_id = _e->str(); }
  { auto _e = text(); if (_e) _o->text = _e->str(); }
}

inline flatbuffers::Offset<InputSetTextParam> InputSetTextParam::Pack(flatbuffers::FlatBufferBuilder &_fbb, const InputSetTextParamT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateInputSetTextParam(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<InputSetTextParam> CreateInputSetTextParam(flatbuffers::FlatBufferBuilder &_fbb, const InputSetTextParamT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const InputSetTextParamT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _object_id = _o->object_id.empty() ? _fbb.CreateSharedString("") : _fbb.CreateString(_o->object_id);
  auto _text = _o->text.empty() ? _fbb.CreateSharedString("") : _fbb.CreateString(_o->text);
  return Gamium::Protocol::Packets::Actions::CreateInputSetTextParam(
      _fbb,
      _object_id,
      _text);
}

inline const flatbuffers::TypeTable *InputKeyParamTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_SHORT, 0, 0 },
    { flatbuffers::ET_STRING, 1, -1 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    Gamium::Protocol::Types::InputKeyPressTypeTypeTable
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 2, type_codes, type_refs, nullptr, nullptr, nullptr
  };
  return &tt;
}

inline const flatbuffers::TypeTable *InputMouseParamTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_SHORT, 0, 0 },
    { flatbuffers::ET_SHORT, 0, 1 },
    { flatbuffers::ET_SEQUENCE, 0, 2 },
    { flatbuffers::ET_SEQUENCE, 0, 2 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    Gamium::Protocol::Types::InputMousePressTypeTypeTable,
    Gamium::Protocol::Types::InputMouseButtonCodeTypeTable,
    Gamium::Protocol::Types::Vector2TypeTable
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 4, type_codes, type_refs, nullptr, nullptr, nullptr
  };
  return &tt;
}

inline const flatbuffers::TypeTable *InputSetTextParamTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_STRING, 0, -1 },
    { flatbuffers::ET_STRING, 0, -1 }
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 2, type_codes, nullptr, nullptr, nullptr, nullptr
  };
  return &tt;
}

}  // namespace Actions
}  // namespace Packets
}  // namespace Protocol
}  // namespace Gamium

#endif  // FLATBUFFERS_GENERATED_INPUTACTION_GAMIUM_PROTOCOL_PACKETS_ACTIONS_H_
