// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_ERRORS_GAMIUM_PROTOCOL_TYPES_H_
#define FLATBUFFERS_GENERATED_ERRORS_GAMIUM_PROTOCOL_TYPES_H_

#include "flatbuffers/flatbuffers.h"

// Ensure the included flatbuffers.h is the same version as when this file was
// generated, otherwise it may not be compatible.
static_assert(FLATBUFFERS_VERSION_MAJOR == 22 &&
              FLATBUFFERS_VERSION_MINOR == 10 &&
              FLATBUFFERS_VERSION_REVISION == 26,
             "Non-compatible flatbuffers version included");

namespace Gamium {
namespace Protocol {
namespace Types {

struct ErrorResult;
struct ErrorResultBuilder;
struct ErrorResultT;

inline const flatbuffers::TypeTable *ErrorResultTypeTable();

enum class ErrorCode : int32_t {
  None = 0,
  Unknown = 1,
  Disconnected = 50,
  Timeout = 51,
  SockerError = 52,
  InternalError = 100,
  InvalidParameter = 150,
  MethodNotFound = 151,
  ObjectNotFound = 200,
  MultipleObjectFound = 201,
  ObjectComponentNotFound = 203,
  ObjectMultipleComponentFound = 204,
  ObjectIsNotActive = 205,
  ObjectIsNotInteractable = 206,
  ObjectIsMoving = 207,
  ObjectSizeIsZero = 208,
  ObjectNothingRaycasted = 209,
  ObjectRaycastedIsAnother = 210,
  InputNotAvailable = 250,
  ExecuteRpcFailed = 300,
  ExecuteRpcInvalidJson = 301,
  ExecuteRpcInternalError = 302,
  ExecuteRpcClassNotFound = 303,
  ExecuteRpcMultipleClassFound = 304,
  ExecuteRpcMethodNotFound = 305,
  ExecuteRpcMultipleMethodFound = 306,
  ExecuteRpcMethodArgumentsLengthMismatch = 307,
  ExecuteRpcMethodArgumentTypeMismatch = 308,
  ExecuteRpcFieldNotFound = 309,
  ExecuteRpcMultipleFieldFound = 310,
  ExecuteRpcPropertyNotFound = 311,
  ExecuteRpcMultiplePropertyFound = 312,
  ExecuteRpcNotSupportedType = 313,
  MIN = None,
  MAX = ExecuteRpcNotSupportedType
};

inline const ErrorCode (&EnumValuesErrorCode())[33] {
  static const ErrorCode values[] = {
    ErrorCode::None,
    ErrorCode::Unknown,
    ErrorCode::Disconnected,
    ErrorCode::Timeout,
    ErrorCode::SockerError,
    ErrorCode::InternalError,
    ErrorCode::InvalidParameter,
    ErrorCode::MethodNotFound,
    ErrorCode::ObjectNotFound,
    ErrorCode::MultipleObjectFound,
    ErrorCode::ObjectComponentNotFound,
    ErrorCode::ObjectMultipleComponentFound,
    ErrorCode::ObjectIsNotActive,
    ErrorCode::ObjectIsNotInteractable,
    ErrorCode::ObjectIsMoving,
    ErrorCode::ObjectSizeIsZero,
    ErrorCode::ObjectNothingRaycasted,
    ErrorCode::ObjectRaycastedIsAnother,
    ErrorCode::InputNotAvailable,
    ErrorCode::ExecuteRpcFailed,
    ErrorCode::ExecuteRpcInvalidJson,
    ErrorCode::ExecuteRpcInternalError,
    ErrorCode::ExecuteRpcClassNotFound,
    ErrorCode::ExecuteRpcMultipleClassFound,
    ErrorCode::ExecuteRpcMethodNotFound,
    ErrorCode::ExecuteRpcMultipleMethodFound,
    ErrorCode::ExecuteRpcMethodArgumentsLengthMismatch,
    ErrorCode::ExecuteRpcMethodArgumentTypeMismatch,
    ErrorCode::ExecuteRpcFieldNotFound,
    ErrorCode::ExecuteRpcMultipleFieldFound,
    ErrorCode::ExecuteRpcPropertyNotFound,
    ErrorCode::ExecuteRpcMultiplePropertyFound,
    ErrorCode::ExecuteRpcNotSupportedType
  };
  return values;
}

inline const char *EnumNameErrorCode(ErrorCode e) {
  switch (e) {
    case ErrorCode::None: return "None";
    case ErrorCode::Unknown: return "Unknown";
    case ErrorCode::Disconnected: return "Disconnected";
    case ErrorCode::Timeout: return "Timeout";
    case ErrorCode::SockerError: return "SockerError";
    case ErrorCode::InternalError: return "InternalError";
    case ErrorCode::InvalidParameter: return "InvalidParameter";
    case ErrorCode::MethodNotFound: return "MethodNotFound";
    case ErrorCode::ObjectNotFound: return "ObjectNotFound";
    case ErrorCode::MultipleObjectFound: return "MultipleObjectFound";
    case ErrorCode::ObjectComponentNotFound: return "ObjectComponentNotFound";
    case ErrorCode::ObjectMultipleComponentFound: return "ObjectMultipleComponentFound";
    case ErrorCode::ObjectIsNotActive: return "ObjectIsNotActive";
    case ErrorCode::ObjectIsNotInteractable: return "ObjectIsNotInteractable";
    case ErrorCode::ObjectIsMoving: return "ObjectIsMoving";
    case ErrorCode::ObjectSizeIsZero: return "ObjectSizeIsZero";
    case ErrorCode::ObjectNothingRaycasted: return "ObjectNothingRaycasted";
    case ErrorCode::ObjectRaycastedIsAnother: return "ObjectRaycastedIsAnother";
    case ErrorCode::InputNotAvailable: return "InputNotAvailable";
    case ErrorCode::ExecuteRpcFailed: return "ExecuteRpcFailed";
    case ErrorCode::ExecuteRpcInvalidJson: return "ExecuteRpcInvalidJson";
    case ErrorCode::ExecuteRpcInternalError: return "ExecuteRpcInternalError";
    case ErrorCode::ExecuteRpcClassNotFound: return "ExecuteRpcClassNotFound";
    case ErrorCode::ExecuteRpcMultipleClassFound: return "ExecuteRpcMultipleClassFound";
    case ErrorCode::ExecuteRpcMethodNotFound: return "ExecuteRpcMethodNotFound";
    case ErrorCode::ExecuteRpcMultipleMethodFound: return "ExecuteRpcMultipleMethodFound";
    case ErrorCode::ExecuteRpcMethodArgumentsLengthMismatch: return "ExecuteRpcMethodArgumentsLengthMismatch";
    case ErrorCode::ExecuteRpcMethodArgumentTypeMismatch: return "ExecuteRpcMethodArgumentTypeMismatch";
    case ErrorCode::ExecuteRpcFieldNotFound: return "ExecuteRpcFieldNotFound";
    case ErrorCode::ExecuteRpcMultipleFieldFound: return "ExecuteRpcMultipleFieldFound";
    case ErrorCode::ExecuteRpcPropertyNotFound: return "ExecuteRpcPropertyNotFound";
    case ErrorCode::ExecuteRpcMultiplePropertyFound: return "ExecuteRpcMultiplePropertyFound";
    case ErrorCode::ExecuteRpcNotSupportedType: return "ExecuteRpcNotSupportedType";
    default: return "";
  }
}

struct ErrorResultT : public flatbuffers::NativeTable {
  typedef ErrorResult TableType;
  Gamium::Protocol::Types::ErrorCode code = Gamium::Protocol::Types::ErrorCode::None;
  std::string reason{};
};

struct ErrorResult FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ErrorResultT NativeTableType;
  typedef ErrorResultBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return ErrorResultTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_CODE = 4,
    VT_REASON = 6
  };
  Gamium::Protocol::Types::ErrorCode code() const {
    return static_cast<Gamium::Protocol::Types::ErrorCode>(GetField<int32_t>(VT_CODE, 0));
  }
  const flatbuffers::String *reason() const {
    return GetPointer<const flatbuffers::String *>(VT_REASON);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_CODE, 4) &&
           VerifyOffset(verifier, VT_REASON) &&
           verifier.VerifyString(reason()) &&
           verifier.EndTable();
  }
  ErrorResultT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(ErrorResultT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<ErrorResult> Pack(flatbuffers::FlatBufferBuilder &_fbb, const ErrorResultT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct ErrorResultBuilder {
  typedef ErrorResult Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_code(Gamium::Protocol::Types::ErrorCode code) {
    fbb_.AddElement<int32_t>(ErrorResult::VT_CODE, static_cast<int32_t>(code), 0);
  }
  void add_reason(flatbuffers::Offset<flatbuffers::String> reason) {
    fbb_.AddOffset(ErrorResult::VT_REASON, reason);
  }
  explicit ErrorResultBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<ErrorResult> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ErrorResult>(end);
    return o;
  }
};

inline flatbuffers::Offset<ErrorResult> CreateErrorResult(
    flatbuffers::FlatBufferBuilder &_fbb,
    Gamium::Protocol::Types::ErrorCode code = Gamium::Protocol::Types::ErrorCode::None,
    flatbuffers::Offset<flatbuffers::String> reason = 0) {
  ErrorResultBuilder builder_(_fbb);
  builder_.add_reason(reason);
  builder_.add_code(code);
  return builder_.Finish();
}

flatbuffers::Offset<ErrorResult> CreateErrorResult(flatbuffers::FlatBufferBuilder &_fbb, const ErrorResultT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

inline ErrorResultT *ErrorResult::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<ErrorResultT>(new ErrorResultT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void ErrorResult::UnPackTo(ErrorResultT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = code(); _o->code = _e; }
  { auto _e = reason(); if (_e) _o->reason = _e->str(); }
}

inline flatbuffers::Offset<ErrorResult> ErrorResult::Pack(flatbuffers::FlatBufferBuilder &_fbb, const ErrorResultT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateErrorResult(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<ErrorResult> CreateErrorResult(flatbuffers::FlatBufferBuilder &_fbb, const ErrorResultT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const ErrorResultT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _code = _o->code;
  auto _reason = _o->reason.empty() ? _fbb.CreateSharedString("") : _fbb.CreateString(_o->reason);
  return Gamium::Protocol::Types::CreateErrorResult(
      _fbb,
      _code,
      _reason);
}

inline const flatbuffers::TypeTable *ErrorCodeTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    Gamium::Protocol::Types::ErrorCodeTypeTable
  };
  static const int64_t values[] = { 0, 1, 50, 51, 52, 100, 150, 151, 200, 201, 203, 204, 205, 206, 207, 208, 209, 210, 250, 300, 301, 302, 303, 304, 305, 306, 307, 308, 309, 310, 311, 312, 313 };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_ENUM, 33, type_codes, type_refs, nullptr, values, nullptr
  };
  return &tt;
}

inline const flatbuffers::TypeTable *ErrorResultTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_STRING, 0, -1 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    Gamium::Protocol::Types::ErrorCodeTypeTable
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 2, type_codes, type_refs, nullptr, nullptr, nullptr
  };
  return &tt;
}

}  // namespace Types
}  // namespace Protocol
}  // namespace Gamium

#endif  // FLATBUFFERS_GENERATED_ERRORS_GAMIUM_PROTOCOL_TYPES_H_
