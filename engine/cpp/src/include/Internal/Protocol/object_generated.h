// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_OBJECT_GAMIUM_PROTOCOL_TYPES_H_
#define FLATBUFFERS_GENERATED_OBJECT_GAMIUM_PROTOCOL_TYPES_H_

#include "flatbuffers/flatbuffers.h"

// Ensure the included flatbuffers.h is the same version as when this file was
// generated, otherwise it may not be compatible.
static_assert(FLATBUFFERS_VERSION_MAJOR == 22 &&
              FLATBUFFERS_VERSION_MINOR == 10 &&
              FLATBUFFERS_VERSION_REVISION == 26,
             "Non-compatible flatbuffers version included");

#include "vector_generated.h"

namespace Gamium {
namespace Protocol {
namespace Types {

struct ObjectLocator;
struct ObjectLocatorBuilder;
struct ObjectLocatorT;

struct ObjectInfo;
struct ObjectInfoBuilder;
struct ObjectInfoT;

inline const flatbuffers::TypeTable *ObjectLocatorTypeTable();

inline const flatbuffers::TypeTable *ObjectInfoTypeTable();

enum class ObjectType : int16_t {
  Unknown = 0,
  UI = 1,
  Camera = 2,
  MIN = Unknown,
  MAX = Camera
};

inline const ObjectType (&EnumValuesObjectType())[3] {
  static const ObjectType values[] = {
    ObjectType::Unknown,
    ObjectType::UI,
    ObjectType::Camera
  };
  return values;
}

inline const char * const *EnumNamesObjectType() {
  static const char * const names[4] = {
    "Unknown",
    "UI",
    "Camera",
    nullptr
  };
  return names;
}

inline const char *EnumNameObjectType(ObjectType e) {
  if (flatbuffers::IsOutRange(e, ObjectType::Unknown, ObjectType::Camera)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesObjectType()[index];
}

enum class ObjectLocatorBy : int16_t {
  Path = 0,
  Tag = 1,
  MIN = Path,
  MAX = Tag
};

inline const ObjectLocatorBy (&EnumValuesObjectLocatorBy())[2] {
  static const ObjectLocatorBy values[] = {
    ObjectLocatorBy::Path,
    ObjectLocatorBy::Tag
  };
  return values;
}

inline const char * const *EnumNamesObjectLocatorBy() {
  static const char * const names[3] = {
    "Path",
    "Tag",
    nullptr
  };
  return names;
}

inline const char *EnumNameObjectLocatorBy(ObjectLocatorBy e) {
  if (flatbuffers::IsOutRange(e, ObjectLocatorBy::Path, ObjectLocatorBy::Tag)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesObjectLocatorBy()[index];
}

struct ObjectLocatorT : public flatbuffers::NativeTable {
  typedef ObjectLocator TableType;
  Gamium::Protocol::Types::ObjectLocatorBy by = Gamium::Protocol::Types::ObjectLocatorBy::Path;
  std::string str{};
};

struct ObjectLocator FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ObjectLocatorT NativeTableType;
  typedef ObjectLocatorBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return ObjectLocatorTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_BY = 4,
    VT_STR = 6
  };
  Gamium::Protocol::Types::ObjectLocatorBy by() const {
    return static_cast<Gamium::Protocol::Types::ObjectLocatorBy>(GetField<int16_t>(VT_BY, 0));
  }
  const flatbuffers::String *str() const {
    return GetPointer<const flatbuffers::String *>(VT_STR);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int16_t>(verifier, VT_BY, 2) &&
           VerifyOffset(verifier, VT_STR) &&
           verifier.VerifyString(str()) &&
           verifier.EndTable();
  }
  ObjectLocatorT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(ObjectLocatorT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<ObjectLocator> Pack(flatbuffers::FlatBufferBuilder &_fbb, const ObjectLocatorT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct ObjectLocatorBuilder {
  typedef ObjectLocator Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_by(Gamium::Protocol::Types::ObjectLocatorBy by) {
    fbb_.AddElement<int16_t>(ObjectLocator::VT_BY, static_cast<int16_t>(by), 0);
  }
  void add_str(flatbuffers::Offset<flatbuffers::String> str) {
    fbb_.AddOffset(ObjectLocator::VT_STR, str);
  }
  explicit ObjectLocatorBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<ObjectLocator> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ObjectLocator>(end);
    return o;
  }
};

inline flatbuffers::Offset<ObjectLocator> CreateObjectLocator(
    flatbuffers::FlatBufferBuilder &_fbb,
    Gamium::Protocol::Types::ObjectLocatorBy by = Gamium::Protocol::Types::ObjectLocatorBy::Path,
    flatbuffers::Offset<flatbuffers::String> str = 0) {
  ObjectLocatorBuilder builder_(_fbb);
  builder_.add_str(str);
  builder_.add_by(by);
  return builder_.Finish();
}

flatbuffers::Offset<ObjectLocator> CreateObjectLocator(flatbuffers::FlatBufferBuilder &_fbb, const ObjectLocatorT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct ObjectInfoT : public flatbuffers::NativeTable {
  typedef ObjectInfo TableType;
  std::string path{};
  std::string name{};
  Gamium::Protocol::Types::ObjectType type = Gamium::Protocol::Types::ObjectType::Unknown;
  std::vector<std::string> tag{};
  bool is_active = false;
  std::unique_ptr<Gamium::Protocol::Types::Vector3> screen_position{};
  std::unique_ptr<Gamium::Protocol::Types::Vector2> screen_rect_size{};
  std::unique_ptr<Gamium::Protocol::Types::Vector3> position{};
  std::unique_ptr<Gamium::Protocol::Types::Vector4> rotation{};
  std::string text{};
  ObjectInfoT() = default;
  ObjectInfoT(const ObjectInfoT &o);
  ObjectInfoT(ObjectInfoT&&) FLATBUFFERS_NOEXCEPT = default;
  ObjectInfoT &operator=(ObjectInfoT o) FLATBUFFERS_NOEXCEPT;
};

struct ObjectInfo FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ObjectInfoT NativeTableType;
  typedef ObjectInfoBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return ObjectInfoTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_PATH = 4,
    VT_NAME = 6,
    VT_TYPE = 8,
    VT_TAG = 10,
    VT_IS_ACTIVE = 12,
    VT_SCREEN_POSITION = 14,
    VT_SCREEN_RECT_SIZE = 16,
    VT_POSITION = 18,
    VT_ROTATION = 20,
    VT_TEXT = 22
  };
  const flatbuffers::String *path() const {
    return GetPointer<const flatbuffers::String *>(VT_PATH);
  }
  const flatbuffers::String *name() const {
    return GetPointer<const flatbuffers::String *>(VT_NAME);
  }
  Gamium::Protocol::Types::ObjectType type() const {
    return static_cast<Gamium::Protocol::Types::ObjectType>(GetField<int16_t>(VT_TYPE, 0));
  }
  const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *tag() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *>(VT_TAG);
  }
  bool is_active() const {
    return GetField<uint8_t>(VT_IS_ACTIVE, 0) != 0;
  }
  const Gamium::Protocol::Types::Vector3 *screen_position() const {
    return GetStruct<const Gamium::Protocol::Types::Vector3 *>(VT_SCREEN_POSITION);
  }
  const Gamium::Protocol::Types::Vector2 *screen_rect_size() const {
    return GetStruct<const Gamium::Protocol::Types::Vector2 *>(VT_SCREEN_RECT_SIZE);
  }
  const Gamium::Protocol::Types::Vector3 *position() const {
    return GetStruct<const Gamium::Protocol::Types::Vector3 *>(VT_POSITION);
  }
  const Gamium::Protocol::Types::Vector4 *rotation() const {
    return GetStruct<const Gamium::Protocol::Types::Vector4 *>(VT_ROTATION);
  }
  const flatbuffers::String *text() const {
    return GetPointer<const flatbuffers::String *>(VT_TEXT);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_PATH) &&
           verifier.VerifyString(path()) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyField<int16_t>(verifier, VT_TYPE, 2) &&
           VerifyOffset(verifier, VT_TAG) &&
           verifier.VerifyVector(tag()) &&
           verifier.VerifyVectorOfStrings(tag()) &&
           VerifyField<uint8_t>(verifier, VT_IS_ACTIVE, 1) &&
           VerifyFieldRequired<Gamium::Protocol::Types::Vector3>(verifier, VT_SCREEN_POSITION, 4) &&
           VerifyField<Gamium::Protocol::Types::Vector2>(verifier, VT_SCREEN_RECT_SIZE, 4) &&
           VerifyFieldRequired<Gamium::Protocol::Types::Vector3>(verifier, VT_POSITION, 4) &&
           VerifyFieldRequired<Gamium::Protocol::Types::Vector4>(verifier, VT_ROTATION, 4) &&
           VerifyOffset(verifier, VT_TEXT) &&
           verifier.VerifyString(text()) &&
           verifier.EndTable();
  }
  ObjectInfoT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(ObjectInfoT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<ObjectInfo> Pack(flatbuffers::FlatBufferBuilder &_fbb, const ObjectInfoT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct ObjectInfoBuilder {
  typedef ObjectInfo Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_path(flatbuffers::Offset<flatbuffers::String> path) {
    fbb_.AddOffset(ObjectInfo::VT_PATH, path);
  }
  void add_name(flatbuffers::Offset<flatbuffers::String> name) {
    fbb_.AddOffset(ObjectInfo::VT_NAME, name);
  }
  void add_type(Gamium::Protocol::Types::ObjectType type) {
    fbb_.AddElement<int16_t>(ObjectInfo::VT_TYPE, static_cast<int16_t>(type), 0);
  }
  void add_tag(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> tag) {
    fbb_.AddOffset(ObjectInfo::VT_TAG, tag);
  }
  void add_is_active(bool is_active) {
    fbb_.AddElement<uint8_t>(ObjectInfo::VT_IS_ACTIVE, static_cast<uint8_t>(is_active), 0);
  }
  void add_screen_position(const Gamium::Protocol::Types::Vector3 *screen_position) {
    fbb_.AddStruct(ObjectInfo::VT_SCREEN_POSITION, screen_position);
  }
  void add_screen_rect_size(const Gamium::Protocol::Types::Vector2 *screen_rect_size) {
    fbb_.AddStruct(ObjectInfo::VT_SCREEN_RECT_SIZE, screen_rect_size);
  }
  void add_position(const Gamium::Protocol::Types::Vector3 *position) {
    fbb_.AddStruct(ObjectInfo::VT_POSITION, position);
  }
  void add_rotation(const Gamium::Protocol::Types::Vector4 *rotation) {
    fbb_.AddStruct(ObjectInfo::VT_ROTATION, rotation);
  }
  void add_text(flatbuffers::Offset<flatbuffers::String> text) {
    fbb_.AddOffset(ObjectInfo::VT_TEXT, text);
  }
  explicit ObjectInfoBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<ObjectInfo> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ObjectInfo>(end);
    fbb_.Required(o, ObjectInfo::VT_PATH);
    fbb_.Required(o, ObjectInfo::VT_SCREEN_POSITION);
    fbb_.Required(o, ObjectInfo::VT_POSITION);
    fbb_.Required(o, ObjectInfo::VT_ROTATION);
    return o;
  }
};

inline flatbuffers::Offset<ObjectInfo> CreateObjectInfo(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> path = 0,
    flatbuffers::Offset<flatbuffers::String> name = 0,
    Gamium::Protocol::Types::ObjectType type = Gamium::Protocol::Types::ObjectType::Unknown,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> tag = 0,
    bool is_active = false,
    const Gamium::Protocol::Types::Vector3 *screen_position = nullptr,
    const Gamium::Protocol::Types::Vector2 *screen_rect_size = nullptr,
    const Gamium::Protocol::Types::Vector3 *position = nullptr,
    const Gamium::Protocol::Types::Vector4 *rotation = nullptr,
    flatbuffers::Offset<flatbuffers::String> text = 0) {
  ObjectInfoBuilder builder_(_fbb);
  builder_.add_text(text);
  builder_.add_rotation(rotation);
  builder_.add_position(position);
  builder_.add_screen_rect_size(screen_rect_size);
  builder_.add_screen_position(screen_position);
  builder_.add_tag(tag);
  builder_.add_name(name);
  builder_.add_path(path);
  builder_.add_type(type);
  builder_.add_is_active(is_active);
  return builder_.Finish();
}

flatbuffers::Offset<ObjectInfo> CreateObjectInfo(flatbuffers::FlatBufferBuilder &_fbb, const ObjectInfoT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

inline ObjectLocatorT *ObjectLocator::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<ObjectLocatorT>(new ObjectLocatorT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void ObjectLocator::UnPackTo(ObjectLocatorT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = by(); _o->by = _e; }
  { auto _e = str(); if (_e) _o->str = _e->str(); }
}

inline flatbuffers::Offset<ObjectLocator> ObjectLocator::Pack(flatbuffers::FlatBufferBuilder &_fbb, const ObjectLocatorT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateObjectLocator(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<ObjectLocator> CreateObjectLocator(flatbuffers::FlatBufferBuilder &_fbb, const ObjectLocatorT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const ObjectLocatorT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _by = _o->by;
  auto _str = _o->str.empty() ? _fbb.CreateSharedString("") : _fbb.CreateString(_o->str);
  return Gamium::Protocol::Types::CreateObjectLocator(
      _fbb,
      _by,
      _str);
}

inline ObjectInfoT::ObjectInfoT(const ObjectInfoT &o)
      : path(o.path),
        name(o.name),
        type(o.type),
        tag(o.tag),
        is_active(o.is_active),
        screen_position((o.screen_position) ? new Gamium::Protocol::Types::Vector3(*o.screen_position) : nullptr),
        screen_rect_size((o.screen_rect_size) ? new Gamium::Protocol::Types::Vector2(*o.screen_rect_size) : nullptr),
        position((o.position) ? new Gamium::Protocol::Types::Vector3(*o.position) : nullptr),
        rotation((o.rotation) ? new Gamium::Protocol::Types::Vector4(*o.rotation) : nullptr),
        text(o.text) {
}

inline ObjectInfoT &ObjectInfoT::operator=(ObjectInfoT o) FLATBUFFERS_NOEXCEPT {
  std::swap(path, o.path);
  std::swap(name, o.name);
  std::swap(type, o.type);
  std::swap(tag, o.tag);
  std::swap(is_active, o.is_active);
  std::swap(screen_position, o.screen_position);
  std::swap(screen_rect_size, o.screen_rect_size);
  std::swap(position, o.position);
  std::swap(rotation, o.rotation);
  std::swap(text, o.text);
  return *this;
}

inline ObjectInfoT *ObjectInfo::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<ObjectInfoT>(new ObjectInfoT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void ObjectInfo::UnPackTo(ObjectInfoT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = path(); if (_e) _o->path = _e->str(); }
  { auto _e = name(); if (_e) _o->name = _e->str(); }
  { auto _e = type(); _o->type = _e; }
  { auto _e = tag(); if (_e) { _o->tag.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->tag[_i] = _e->Get(_i)->str(); } } else { _o->tag.resize(0); } }
  { auto _e = is_active(); _o->is_active = _e; }
  { auto _e = screen_position(); if (_e) _o->screen_position = std::unique_ptr<Gamium::Protocol::Types::Vector3>(new Gamium::Protocol::Types::Vector3(*_e)); }
  { auto _e = screen_rect_size(); if (_e) _o->screen_rect_size = std::unique_ptr<Gamium::Protocol::Types::Vector2>(new Gamium::Protocol::Types::Vector2(*_e)); }
  { auto _e = position(); if (_e) _o->position = std::unique_ptr<Gamium::Protocol::Types::Vector3>(new Gamium::Protocol::Types::Vector3(*_e)); }
  { auto _e = rotation(); if (_e) _o->rotation = std::unique_ptr<Gamium::Protocol::Types::Vector4>(new Gamium::Protocol::Types::Vector4(*_e)); }
  { auto _e = text(); if (_e) _o->text = _e->str(); }
}

inline flatbuffers::Offset<ObjectInfo> ObjectInfo::Pack(flatbuffers::FlatBufferBuilder &_fbb, const ObjectInfoT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateObjectInfo(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<ObjectInfo> CreateObjectInfo(flatbuffers::FlatBufferBuilder &_fbb, const ObjectInfoT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const ObjectInfoT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _path = _fbb.CreateString(_o->path);
  auto _name = _o->name.empty() ? _fbb.CreateSharedString("") : _fbb.CreateString(_o->name);
  auto _type = _o->type;
  auto _tag = _fbb.CreateVectorOfStrings(_o->tag);
  auto _is_active = _o->is_active;
  auto _screen_position = _o->screen_position ? _o->screen_position.get() : nullptr;
  auto _screen_rect_size = _o->screen_rect_size ? _o->screen_rect_size.get() : nullptr;
  auto _position = _o->position ? _o->position.get() : nullptr;
  auto _rotation = _o->rotation ? _o->rotation.get() : nullptr;
  auto _text = _o->text.empty() ? _fbb.CreateSharedString("") : _fbb.CreateString(_o->text);
  return Gamium::Protocol::Types::CreateObjectInfo(
      _fbb,
      _path,
      _name,
      _type,
      _tag,
      _is_active,
      _screen_position,
      _screen_rect_size,
      _position,
      _rotation,
      _text);
}

inline const flatbuffers::TypeTable *ObjectTypeTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_SHORT, 0, 0 },
    { flatbuffers::ET_SHORT, 0, 0 },
    { flatbuffers::ET_SHORT, 0, 0 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    Gamium::Protocol::Types::ObjectTypeTypeTable
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_ENUM, 3, type_codes, type_refs, nullptr, nullptr, nullptr
  };
  return &tt;
}

inline const flatbuffers::TypeTable *ObjectLocatorByTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_SHORT, 0, 0 },
    { flatbuffers::ET_SHORT, 0, 0 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    Gamium::Protocol::Types::ObjectLocatorByTypeTable
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_ENUM, 2, type_codes, type_refs, nullptr, nullptr, nullptr
  };
  return &tt;
}

inline const flatbuffers::TypeTable *ObjectLocatorTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_SHORT, 0, 0 },
    { flatbuffers::ET_STRING, 0, -1 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    Gamium::Protocol::Types::ObjectLocatorByTypeTable
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 2, type_codes, type_refs, nullptr, nullptr, nullptr
  };
  return &tt;
}

inline const flatbuffers::TypeTable *ObjectInfoTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_STRING, 0, -1 },
    { flatbuffers::ET_STRING, 0, -1 },
    { flatbuffers::ET_SHORT, 0, 0 },
    { flatbuffers::ET_STRING, 1, -1 },
    { flatbuffers::ET_BOOL, 0, -1 },
    { flatbuffers::ET_SEQUENCE, 0, 1 },
    { flatbuffers::ET_SEQUENCE, 0, 2 },
    { flatbuffers::ET_SEQUENCE, 0, 1 },
    { flatbuffers::ET_SEQUENCE, 0, 3 },
    { flatbuffers::ET_STRING, 0, -1 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    Gamium::Protocol::Types::ObjectTypeTypeTable,
    Gamium::Protocol::Types::Vector3TypeTable,
    Gamium::Protocol::Types::Vector2TypeTable,
    Gamium::Protocol::Types::Vector4TypeTable
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 10, type_codes, type_refs, nullptr, nullptr, nullptr
  };
  return &tt;
}

}  // namespace Types
}  // namespace Protocol
}  // namespace Gamium

#endif  // FLATBUFFERS_GENERATED_OBJECT_GAMIUM_PROTOCOL_TYPES_H_
