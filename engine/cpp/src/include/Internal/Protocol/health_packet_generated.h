// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_HEALTHPACKET_GAMIUM_PROTOCOL_PACKETS_H_
#define FLATBUFFERS_GENERATED_HEALTHPACKET_GAMIUM_PROTOCOL_PACKETS_H_

#include "flatbuffers/flatbuffers.h"

// Ensure the included flatbuffers.h is the same version as when this file was
// generated, otherwise it may not be compatible.
static_assert(FLATBUFFERS_VERSION_MAJOR == 22 &&
              FLATBUFFERS_VERSION_MINOR == 10 &&
              FLATBUFFERS_VERSION_REVISION == 26,
             "Non-compatible flatbuffers version included");

namespace Gamium {
namespace Protocol {
namespace Packets {

struct HelloParam;
struct HelloParamBuilder;
struct HelloParamT;

struct Env;
struct EnvBuilder;
struct EnvT;

struct HelloResult;
struct HelloResultBuilder;
struct HelloResultT;

inline const flatbuffers::TypeTable *HelloParamTypeTable();

inline const flatbuffers::TypeTable *EnvTypeTable();

inline const flatbuffers::TypeTable *HelloResultTypeTable();

struct HelloParamT : public flatbuffers::NativeTable {
  typedef HelloParam TableType;
  std::string version{};
};

struct HelloParam FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef HelloParamT NativeTableType;
  typedef HelloParamBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return HelloParamTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_VERSION = 4
  };
  const flatbuffers::String *version() const {
    return GetPointer<const flatbuffers::String *>(VT_VERSION);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_VERSION) &&
           verifier.VerifyString(version()) &&
           verifier.EndTable();
  }
  HelloParamT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(HelloParamT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<HelloParam> Pack(flatbuffers::FlatBufferBuilder &_fbb, const HelloParamT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct HelloParamBuilder {
  typedef HelloParam Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_version(flatbuffers::Offset<flatbuffers::String> version) {
    fbb_.AddOffset(HelloParam::VT_VERSION, version);
  }
  explicit HelloParamBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<HelloParam> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<HelloParam>(end);
    return o;
  }
};

inline flatbuffers::Offset<HelloParam> CreateHelloParam(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> version = 0) {
  HelloParamBuilder builder_(_fbb);
  builder_.add_version(version);
  return builder_.Finish();
}

flatbuffers::Offset<HelloParam> CreateHelloParam(flatbuffers::FlatBufferBuilder &_fbb, const HelloParamT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct EnvT : public flatbuffers::NativeTable {
  typedef Env TableType;
  std::string key{};
  std::string value{};
};

struct Env FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef EnvT NativeTableType;
  typedef EnvBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return EnvTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_KEY = 4,
    VT_VALUE = 6
  };
  const flatbuffers::String *key() const {
    return GetPointer<const flatbuffers::String *>(VT_KEY);
  }
  const flatbuffers::String *value() const {
    return GetPointer<const flatbuffers::String *>(VT_VALUE);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_KEY) &&
           verifier.VerifyString(key()) &&
           VerifyOffset(verifier, VT_VALUE) &&
           verifier.VerifyString(value()) &&
           verifier.EndTable();
  }
  EnvT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(EnvT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Env> Pack(flatbuffers::FlatBufferBuilder &_fbb, const EnvT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct EnvBuilder {
  typedef Env Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_key(flatbuffers::Offset<flatbuffers::String> key) {
    fbb_.AddOffset(Env::VT_KEY, key);
  }
  void add_value(flatbuffers::Offset<flatbuffers::String> value) {
    fbb_.AddOffset(Env::VT_VALUE, value);
  }
  explicit EnvBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Env> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Env>(end);
    return o;
  }
};

inline flatbuffers::Offset<Env> CreateEnv(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> key = 0,
    flatbuffers::Offset<flatbuffers::String> value = 0) {
  EnvBuilder builder_(_fbb);
  builder_.add_value(value);
  builder_.add_key(key);
  return builder_.Finish();
}

flatbuffers::Offset<Env> CreateEnv(flatbuffers::FlatBufferBuilder &_fbb, const EnvT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct HelloResultT : public flatbuffers::NativeTable {
  typedef HelloResult TableType;
  std::string app_name{};
  std::string app_version{};
  std::string gamium_version{};
  uint64_t frames_from_start = 0;
  float seconds_from_start = 0.0f;
  uint32_t client_sequence = 0;
  std::vector<Gamium::Protocol::Packets::EnvT> envs{};
};

struct HelloResult FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef HelloResultT NativeTableType;
  typedef HelloResultBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return HelloResultTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_APP_NAME = 4,
    VT_APP_VERSION = 6,
    VT_GAMIUM_VERSION = 8,
    VT_FRAMES_FROM_START = 10,
    VT_SECONDS_FROM_START = 12,
    VT_CLIENT_SEQUENCE = 14,
    VT_ENVS = 16
  };
  const flatbuffers::String *app_name() const {
    return GetPointer<const flatbuffers::String *>(VT_APP_NAME);
  }
  const flatbuffers::String *app_version() const {
    return GetPointer<const flatbuffers::String *>(VT_APP_VERSION);
  }
  const flatbuffers::String *gamium_version() const {
    return GetPointer<const flatbuffers::String *>(VT_GAMIUM_VERSION);
  }
  uint64_t frames_from_start() const {
    return GetField<uint64_t>(VT_FRAMES_FROM_START, 0);
  }
  float seconds_from_start() const {
    return GetField<float>(VT_SECONDS_FROM_START, 0.0f);
  }
  uint32_t client_sequence() const {
    return GetField<uint32_t>(VT_CLIENT_SEQUENCE, 0);
  }
  const flatbuffers::Vector<flatbuffers::Offset<Gamium::Protocol::Packets::Env>> *envs() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<Gamium::Protocol::Packets::Env>> *>(VT_ENVS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_APP_NAME) &&
           verifier.VerifyString(app_name()) &&
           VerifyOffset(verifier, VT_APP_VERSION) &&
           verifier.VerifyString(app_version()) &&
           VerifyOffset(verifier, VT_GAMIUM_VERSION) &&
           verifier.VerifyString(gamium_version()) &&
           VerifyField<uint64_t>(verifier, VT_FRAMES_FROM_START, 8) &&
           VerifyField<float>(verifier, VT_SECONDS_FROM_START, 4) &&
           VerifyField<uint32_t>(verifier, VT_CLIENT_SEQUENCE, 4) &&
           VerifyOffset(verifier, VT_ENVS) &&
           verifier.VerifyVector(envs()) &&
           verifier.VerifyVectorOfTables(envs()) &&
           verifier.EndTable();
  }
  HelloResultT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(HelloResultT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<HelloResult> Pack(flatbuffers::FlatBufferBuilder &_fbb, const HelloResultT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct HelloResultBuilder {
  typedef HelloResult Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_app_name(flatbuffers::Offset<flatbuffers::String> app_name) {
    fbb_.AddOffset(HelloResult::VT_APP_NAME, app_name);
  }
  void add_app_version(flatbuffers::Offset<flatbuffers::String> app_version) {
    fbb_.AddOffset(HelloResult::VT_APP_VERSION, app_version);
  }
  void add_gamium_version(flatbuffers::Offset<flatbuffers::String> gamium_version) {
    fbb_.AddOffset(HelloResult::VT_GAMIUM_VERSION, gamium_version);
  }
  void add_frames_from_start(uint64_t frames_from_start) {
    fbb_.AddElement<uint64_t>(HelloResult::VT_FRAMES_FROM_START, frames_from_start, 0);
  }
  void add_seconds_from_start(float seconds_from_start) {
    fbb_.AddElement<float>(HelloResult::VT_SECONDS_FROM_START, seconds_from_start, 0.0f);
  }
  void add_client_sequence(uint32_t client_sequence) {
    fbb_.AddElement<uint32_t>(HelloResult::VT_CLIENT_SEQUENCE, client_sequence, 0);
  }
  void add_envs(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Gamium::Protocol::Packets::Env>>> envs) {
    fbb_.AddOffset(HelloResult::VT_ENVS, envs);
  }
  explicit HelloResultBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<HelloResult> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<HelloResult>(end);
    return o;
  }
};

inline flatbuffers::Offset<HelloResult> CreateHelloResult(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> app_name = 0,
    flatbuffers::Offset<flatbuffers::String> app_version = 0,
    flatbuffers::Offset<flatbuffers::String> gamium_version = 0,
    uint64_t frames_from_start = 0,
    float seconds_from_start = 0.0f,
    uint32_t client_sequence = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Gamium::Protocol::Packets::Env>>> envs = 0) {
  HelloResultBuilder builder_(_fbb);
  builder_.add_frames_from_start(frames_from_start);
  builder_.add_envs(envs);
  builder_.add_client_sequence(client_sequence);
  builder_.add_seconds_from_start(seconds_from_start);
  builder_.add_gamium_version(gamium_version);
  builder_.add_app_version(app_version);
  builder_.add_app_name(app_name);
  return builder_.Finish();
}

flatbuffers::Offset<HelloResult> CreateHelloResult(flatbuffers::FlatBufferBuilder &_fbb, const HelloResultT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

inline HelloParamT *HelloParam::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<HelloParamT>(new HelloParamT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void HelloParam::UnPackTo(HelloParamT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = version(); if (_e) _o->version = _e->str(); }
}

inline flatbuffers::Offset<HelloParam> HelloParam::Pack(flatbuffers::FlatBufferBuilder &_fbb, const HelloParamT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateHelloParam(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<HelloParam> CreateHelloParam(flatbuffers::FlatBufferBuilder &_fbb, const HelloParamT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const HelloParamT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _version = _o->version.empty() ? _fbb.CreateSharedString("") : _fbb.CreateString(_o->version);
  return Gamium::Protocol::Packets::CreateHelloParam(
      _fbb,
      _version);
}

inline EnvT *Env::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<EnvT>(new EnvT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void Env::UnPackTo(EnvT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = key(); if (_e) _o->key = _e->str(); }
  { auto _e = value(); if (_e) _o->value = _e->str(); }
}

inline flatbuffers::Offset<Env> Env::Pack(flatbuffers::FlatBufferBuilder &_fbb, const EnvT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateEnv(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Env> CreateEnv(flatbuffers::FlatBufferBuilder &_fbb, const EnvT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const EnvT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _key = _o->key.empty() ? _fbb.CreateSharedString("") : _fbb.CreateString(_o->key);
  auto _value = _o->value.empty() ? _fbb.CreateSharedString("") : _fbb.CreateString(_o->value);
  return Gamium::Protocol::Packets::CreateEnv(
      _fbb,
      _key,
      _value);
}

inline HelloResultT *HelloResult::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<HelloResultT>(new HelloResultT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void HelloResult::UnPackTo(HelloResultT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = app_name(); if (_e) _o->app_name = _e->str(); }
  { auto _e = app_version(); if (_e) _o->app_version = _e->str(); }
  { auto _e = gamium_version(); if (_e) _o->gamium_version = _e->str(); }
  { auto _e = frames_from_start(); _o->frames_from_start = _e; }
  { auto _e = seconds_from_start(); _o->seconds_from_start = _e; }
  { auto _e = client_sequence(); _o->client_sequence = _e; }
  { auto _e = envs(); if (_e) { _o->envs.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->envs[_i] = *std::unique_ptr<Gamium::Protocol::Packets::EnvT>(_e->Get(_i)->UnPack(_resolver)); } } else { _o->envs.resize(0); } }
}

inline flatbuffers::Offset<HelloResult> HelloResult::Pack(flatbuffers::FlatBufferBuilder &_fbb, const HelloResultT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateHelloResult(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<HelloResult> CreateHelloResult(flatbuffers::FlatBufferBuilder &_fbb, const HelloResultT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const HelloResultT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _app_name = _o->app_name.empty() ? _fbb.CreateSharedString("") : _fbb.CreateString(_o->app_name);
  auto _app_version = _o->app_version.empty() ? _fbb.CreateSharedString("") : _fbb.CreateString(_o->app_version);
  auto _gamium_version = _o->gamium_version.empty() ? _fbb.CreateSharedString("") : _fbb.CreateString(_o->gamium_version);
  auto _frames_from_start = _o->frames_from_start;
  auto _seconds_from_start = _o->seconds_from_start;
  auto _client_sequence = _o->client_sequence;
  auto _envs = _fbb.CreateVector<flatbuffers::Offset<Gamium::Protocol::Packets::Env>> (_o->envs.size(), [](size_t i, _VectorArgs *__va) { return CreateEnv(*__va->__fbb, &(__va->__o->envs[i]), __va->__rehasher); }, &_va );
  return Gamium::Protocol::Packets::CreateHelloResult(
      _fbb,
      _app_name,
      _app_version,
      _gamium_version,
      _frames_from_start,
      _seconds_from_start,
      _client_sequence,
      _envs);
}

inline const flatbuffers::TypeTable *HelloParamTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_STRING, 0, -1 }
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 1, type_codes, nullptr, nullptr, nullptr, nullptr
  };
  return &tt;
}

inline const flatbuffers::TypeTable *EnvTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_STRING, 0, -1 },
    { flatbuffers::ET_STRING, 0, -1 }
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 2, type_codes, nullptr, nullptr, nullptr, nullptr
  };
  return &tt;
}

inline const flatbuffers::TypeTable *HelloResultTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_STRING, 0, -1 },
    { flatbuffers::ET_STRING, 0, -1 },
    { flatbuffers::ET_STRING, 0, -1 },
    { flatbuffers::ET_ULONG, 0, -1 },
    { flatbuffers::ET_FLOAT, 0, -1 },
    { flatbuffers::ET_UINT, 0, -1 },
    { flatbuffers::ET_SEQUENCE, 1, 0 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    Gamium::Protocol::Packets::EnvTypeTable
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 7, type_codes, type_refs, nullptr, nullptr, nullptr
  };
  return &tt;
}

}  // namespace Packets
}  // namespace Protocol
}  // namespace Gamium

#endif  // FLATBUFFERS_GENERATED_HEALTHPACKET_GAMIUM_PROTOCOL_PACKETS_H_
