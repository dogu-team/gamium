// automatically generated by the FlatBuffers compiler, do not modify

import * as flatbuffers from 'flatbuffers';

import { ActionsResult, ActionsResultT } from '../../gamium/protocol/packets/actions-result.js';
import { ChangeConfigurationResult, ChangeConfigurationResultT } from '../../gamium/protocol/packets/change-configuration-result.js';
import { DumpObjectsHierarchyResult, DumpObjectsHierarchyResultT } from '../../gamium/protocol/packets/dump-objects-hierarchy-result.js';
import { ExecuteRpcResult, ExecuteRpcResultT } from '../../gamium/protocol/packets/execute-rpc-result.js';
import { FindObjectsResult, FindObjectsResultT } from '../../gamium/protocol/packets/find-objects-result.js';
import { HelloResult, HelloResultT } from '../../gamium/protocol/packets/hello-result.js';
import { InspectObjectOnScreenResult, InspectObjectOnScreenResultT } from '../../gamium/protocol/packets/inspect-object-on-screen-result.js';
import { InspectObjectWithIdResult, InspectObjectWithIdResultT } from '../../gamium/protocol/packets/inspect-object-with-id-result.js';
import { QueryObjectInteractableResult, QueryObjectInteractableResultT } from '../../gamium/protocol/packets/query-object-interactable-result.js';
import { QueryProfileResult, QueryProfileResultT } from '../../gamium/protocol/packets/query-profile-result.js';
import { QueryScreenResult, QueryScreenResultT } from '../../gamium/protocol/packets/query-screen-result.js';
import { Result, unionToResult, unionListToResult } from '../../gamium/protocol/result.js';
import { ErrorResult, ErrorResultT } from '../../gamium/protocol/types/error-result.js';

export class Response implements flatbuffers.IUnpackableObject<ResponseT> {
  bb: flatbuffers.ByteBuffer | null = null;
  bb_pos = 0;
  __init(i: number, bb: flatbuffers.ByteBuffer): Response {
    this.bb_pos = i;
    this.bb = bb;
    return this;
  }

  static getRootAsResponse(bb: flatbuffers.ByteBuffer, obj?: Response): Response {
    return (obj || new Response()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
  }

  static getSizePrefixedRootAsResponse(bb: flatbuffers.ByteBuffer, obj?: Response): Response {
    bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
    return (obj || new Response()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
  }

  seq(): number {
    const offset = this.bb!.__offset(this.bb_pos, 4);
    return offset ? this.bb!.readUint32(this.bb_pos + offset) : 0;
  }

  error(obj?: ErrorResult): ErrorResult | null {
    const offset = this.bb!.__offset(this.bb_pos, 6);
    return offset ? (obj || new ErrorResult()).__init(this.bb!.__indirect(this.bb_pos + offset), this.bb!) : null;
  }

  resultType(): Result {
    const offset = this.bb!.__offset(this.bb_pos, 8);
    return offset ? this.bb!.readUint8(this.bb_pos + offset) : Result.NONE;
  }

  result<T extends flatbuffers.Table>(obj: any): any | null {
    const offset = this.bb!.__offset(this.bb_pos, 10);
    return offset ? this.bb!.__union(obj, this.bb_pos + offset) : null;
  }

  static startResponse(builder: flatbuffers.Builder) {
    builder.startObject(4);
  }

  static addSeq(builder: flatbuffers.Builder, seq: number) {
    builder.addFieldInt32(0, seq, 0);
  }

  static addError(builder: flatbuffers.Builder, errorOffset: flatbuffers.Offset) {
    builder.addFieldOffset(1, errorOffset, 0);
  }

  static addResultType(builder: flatbuffers.Builder, resultType: Result) {
    builder.addFieldInt8(2, resultType, Result.NONE);
  }

  static addResult(builder: flatbuffers.Builder, resultOffset: flatbuffers.Offset) {
    builder.addFieldOffset(3, resultOffset, 0);
  }

  static endResponse(builder: flatbuffers.Builder): flatbuffers.Offset {
    const offset = builder.endObject();
    return offset;
  }

  static finishResponseBuffer(builder: flatbuffers.Builder, offset: flatbuffers.Offset) {
    builder.finish(offset);
  }

  static finishSizePrefixedResponseBuffer(builder: flatbuffers.Builder, offset: flatbuffers.Offset) {
    builder.finish(offset, undefined, true);
  }

  unpack(): ResponseT {
    return new ResponseT(
      this.seq(),
      this.error() !== null ? this.error()!.unpack() : null,
      this.resultType(),
      (() => {
        const temp = unionToResult(this.resultType(), this.result.bind(this));
        if (temp === null) {
          return null;
        }
        return temp.unpack();
      })(),
    );
  }

  unpackTo(_o: ResponseT): void {
    _o.seq = this.seq();
    _o.error = this.error() !== null ? this.error()!.unpack() : null;
    _o.resultType = this.resultType();
    _o.result = (() => {
      const temp = unionToResult(this.resultType(), this.result.bind(this));
      if (temp === null) {
        return null;
      }
      return temp.unpack();
    })();
  }
}

export class ResponseT implements flatbuffers.IGeneratedObject {
  constructor(
    public seq: number = 0,
    public error: ErrorResultT | null = null,
    public resultType: Result = Result.NONE,
    public result:
      | ActionsResultT
      | ChangeConfigurationResultT
      | DumpObjectsHierarchyResultT
      | ExecuteRpcResultT
      | FindObjectsResultT
      | HelloResultT
      | InspectObjectOnScreenResultT
      | InspectObjectWithIdResultT
      | QueryObjectInteractableResultT
      | QueryProfileResultT
      | QueryScreenResultT
      | null = null,
  ) {}

  pack(builder: flatbuffers.Builder): flatbuffers.Offset {
    const error = this.error !== null ? this.error!.pack(builder) : 0;
    const result = builder.createObjectOffset(this.result);

    Response.startResponse(builder);
    Response.addSeq(builder, this.seq);
    Response.addError(builder, error);
    Response.addResultType(builder, this.resultType);
    Response.addResult(builder, result);

    return Response.endResponse(builder);
  }
}
