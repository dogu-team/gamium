// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_INSPECTORPACKET_GAMIUM_PROTOCOL_PACKETS_H_
#define FLATBUFFERS_GENERATED_INSPECTORPACKET_GAMIUM_PROTOCOL_PACKETS_H_

#include "flatbuffers/flatbuffers.h"

// Ensure the included flatbuffers.h is the same version as when this file was
// generated, otherwise it may not be compatible.
static_assert(FLATBUFFERS_VERSION_MAJOR == 22 &&
              FLATBUFFERS_VERSION_MINOR == 10 &&
              FLATBUFFERS_VERSION_REVISION == 26,
             "Non-compatible flatbuffers version included");

#include "object_generated.h"
#include "object_hierarchy_generated.h"
#include "vector_generated.h"

namespace Gamium {
namespace Protocol {
namespace Packets {

struct InspectObjectOnScreenParam;
struct InspectObjectOnScreenParamBuilder;
struct InspectObjectOnScreenParamT;

struct InspectObjectOnScreenResult;
struct InspectObjectOnScreenResultBuilder;
struct InspectObjectOnScreenResultT;

struct InspectObjectWithIdParam;
struct InspectObjectWithIdParamBuilder;
struct InspectObjectWithIdParamT;

struct InspectObjectWithIdResult;
struct InspectObjectWithIdResultBuilder;
struct InspectObjectWithIdResultT;

struct DumpObjectsHierarchyParam;
struct DumpObjectsHierarchyParamBuilder;
struct DumpObjectsHierarchyParamT;

struct DumpObjectsHierarchyResult;
struct DumpObjectsHierarchyResultBuilder;
struct DumpObjectsHierarchyResultT;

struct GetPageSourceParam;
struct GetPageSourceParamBuilder;
struct GetPageSourceParamT;

struct GetPageSourceResult;
struct GetPageSourceResultBuilder;
struct GetPageSourceResultT;

inline const flatbuffers::TypeTable *InspectObjectOnScreenParamTypeTable();

inline const flatbuffers::TypeTable *InspectObjectOnScreenResultTypeTable();

inline const flatbuffers::TypeTable *InspectObjectWithIdParamTypeTable();

inline const flatbuffers::TypeTable *InspectObjectWithIdResultTypeTable();

inline const flatbuffers::TypeTable *DumpObjectsHierarchyParamTypeTable();

inline const flatbuffers::TypeTable *DumpObjectsHierarchyResultTypeTable();

inline const flatbuffers::TypeTable *GetPageSourceParamTypeTable();

inline const flatbuffers::TypeTable *GetPageSourceResultTypeTable();

struct InspectObjectOnScreenParamT : public flatbuffers::NativeTable {
  typedef InspectObjectOnScreenParam TableType;
  std::unique_ptr<Gamium::Protocol::Types::Vector2> pos{};
  std::unique_ptr<Gamium::Protocol::Types::Vector2> screen_size{};
  InspectObjectOnScreenParamT() = default;
  InspectObjectOnScreenParamT(const InspectObjectOnScreenParamT &o);
  InspectObjectOnScreenParamT(InspectObjectOnScreenParamT&&) FLATBUFFERS_NOEXCEPT = default;
  InspectObjectOnScreenParamT &operator=(InspectObjectOnScreenParamT o) FLATBUFFERS_NOEXCEPT;
};

struct InspectObjectOnScreenParam FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef InspectObjectOnScreenParamT NativeTableType;
  typedef InspectObjectOnScreenParamBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return InspectObjectOnScreenParamTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_POS = 4,
    VT_SCREEN_SIZE = 6
  };
  const Gamium::Protocol::Types::Vector2 *pos() const {
    return GetStruct<const Gamium::Protocol::Types::Vector2 *>(VT_POS);
  }
  const Gamium::Protocol::Types::Vector2 *screen_size() const {
    return GetStruct<const Gamium::Protocol::Types::Vector2 *>(VT_SCREEN_SIZE);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<Gamium::Protocol::Types::Vector2>(verifier, VT_POS, 4) &&
           VerifyField<Gamium::Protocol::Types::Vector2>(verifier, VT_SCREEN_SIZE, 4) &&
           verifier.EndTable();
  }
  InspectObjectOnScreenParamT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(InspectObjectOnScreenParamT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<InspectObjectOnScreenParam> Pack(flatbuffers::FlatBufferBuilder &_fbb, const InspectObjectOnScreenParamT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct InspectObjectOnScreenParamBuilder {
  typedef InspectObjectOnScreenParam Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_pos(const Gamium::Protocol::Types::Vector2 *pos) {
    fbb_.AddStruct(InspectObjectOnScreenParam::VT_POS, pos);
  }
  void add_screen_size(const Gamium::Protocol::Types::Vector2 *screen_size) {
    fbb_.AddStruct(InspectObjectOnScreenParam::VT_SCREEN_SIZE, screen_size);
  }
  explicit InspectObjectOnScreenParamBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<InspectObjectOnScreenParam> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<InspectObjectOnScreenParam>(end);
    return o;
  }
};

inline flatbuffers::Offset<InspectObjectOnScreenParam> CreateInspectObjectOnScreenParam(
    flatbuffers::FlatBufferBuilder &_fbb,
    const Gamium::Protocol::Types::Vector2 *pos = nullptr,
    const Gamium::Protocol::Types::Vector2 *screen_size = nullptr) {
  InspectObjectOnScreenParamBuilder builder_(_fbb);
  builder_.add_screen_size(screen_size);
  builder_.add_pos(pos);
  return builder_.Finish();
}

flatbuffers::Offset<InspectObjectOnScreenParam> CreateInspectObjectOnScreenParam(flatbuffers::FlatBufferBuilder &_fbb, const InspectObjectOnScreenParamT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct InspectObjectOnScreenResultT : public flatbuffers::NativeTable {
  typedef InspectObjectOnScreenResult TableType;
  std::vector<Gamium::Protocol::Types::ObjectInfoT> infos{};
  std::unique_ptr<Gamium::Protocol::Types::Vector3> hit_point{};
  InspectObjectOnScreenResultT() = default;
  InspectObjectOnScreenResultT(const InspectObjectOnScreenResultT &o);
  InspectObjectOnScreenResultT(InspectObjectOnScreenResultT&&) FLATBUFFERS_NOEXCEPT = default;
  InspectObjectOnScreenResultT &operator=(InspectObjectOnScreenResultT o) FLATBUFFERS_NOEXCEPT;
};

struct InspectObjectOnScreenResult FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef InspectObjectOnScreenResultT NativeTableType;
  typedef InspectObjectOnScreenResultBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return InspectObjectOnScreenResultTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_INFOS = 4,
    VT_HIT_POINT = 6
  };
  const flatbuffers::Vector<flatbuffers::Offset<Gamium::Protocol::Types::ObjectInfo>> *infos() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<Gamium::Protocol::Types::ObjectInfo>> *>(VT_INFOS);
  }
  const Gamium::Protocol::Types::Vector3 *hit_point() const {
    return GetStruct<const Gamium::Protocol::Types::Vector3 *>(VT_HIT_POINT);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_INFOS) &&
           verifier.VerifyVector(infos()) &&
           verifier.VerifyVectorOfTables(infos()) &&
           VerifyField<Gamium::Protocol::Types::Vector3>(verifier, VT_HIT_POINT, 4) &&
           verifier.EndTable();
  }
  InspectObjectOnScreenResultT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(InspectObjectOnScreenResultT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<InspectObjectOnScreenResult> Pack(flatbuffers::FlatBufferBuilder &_fbb, const InspectObjectOnScreenResultT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct InspectObjectOnScreenResultBuilder {
  typedef InspectObjectOnScreenResult Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_infos(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Gamium::Protocol::Types::ObjectInfo>>> infos) {
    fbb_.AddOffset(InspectObjectOnScreenResult::VT_INFOS, infos);
  }
  void add_hit_point(const Gamium::Protocol::Types::Vector3 *hit_point) {
    fbb_.AddStruct(InspectObjectOnScreenResult::VT_HIT_POINT, hit_point);
  }
  explicit InspectObjectOnScreenResultBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<InspectObjectOnScreenResult> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<InspectObjectOnScreenResult>(end);
    return o;
  }
};

inline flatbuffers::Offset<InspectObjectOnScreenResult> CreateInspectObjectOnScreenResult(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Gamium::Protocol::Types::ObjectInfo>>> infos = 0,
    const Gamium::Protocol::Types::Vector3 *hit_point = nullptr) {
  InspectObjectOnScreenResultBuilder builder_(_fbb);
  builder_.add_hit_point(hit_point);
  builder_.add_infos(infos);
  return builder_.Finish();
}

flatbuffers::Offset<InspectObjectOnScreenResult> CreateInspectObjectOnScreenResult(flatbuffers::FlatBufferBuilder &_fbb, const InspectObjectOnScreenResultT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct InspectObjectWithIdParamT : public flatbuffers::NativeTable {
  typedef InspectObjectWithIdParam TableType;
  std::string object_id{};
};

struct InspectObjectWithIdParam FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef InspectObjectWithIdParamT NativeTableType;
  typedef InspectObjectWithIdParamBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return InspectObjectWithIdParamTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_OBJECT_ID = 4
  };
  const flatbuffers::String *object_id() const {
    return GetPointer<const flatbuffers::String *>(VT_OBJECT_ID);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_OBJECT_ID) &&
           verifier.VerifyString(object_id()) &&
           verifier.EndTable();
  }
  InspectObjectWithIdParamT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(InspectObjectWithIdParamT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<InspectObjectWithIdParam> Pack(flatbuffers::FlatBufferBuilder &_fbb, const InspectObjectWithIdParamT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct InspectObjectWithIdParamBuilder {
  typedef InspectObjectWithIdParam Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_object_id(flatbuffers::Offset<flatbuffers::String> object_id) {
    fbb_.AddOffset(InspectObjectWithIdParam::VT_OBJECT_ID, object_id);
  }
  explicit InspectObjectWithIdParamBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<InspectObjectWithIdParam> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<InspectObjectWithIdParam>(end);
    return o;
  }
};

inline flatbuffers::Offset<InspectObjectWithIdParam> CreateInspectObjectWithIdParam(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> object_id = 0) {
  InspectObjectWithIdParamBuilder builder_(_fbb);
  builder_.add_object_id(object_id);
  return builder_.Finish();
}

flatbuffers::Offset<InspectObjectWithIdParam> CreateInspectObjectWithIdParam(flatbuffers::FlatBufferBuilder &_fbb, const InspectObjectWithIdParamT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct InspectObjectWithIdResultT : public flatbuffers::NativeTable {
  typedef InspectObjectWithIdResult TableType;
  std::unique_ptr<Gamium::Protocol::Types::ObjectInfoT> info{};
  InspectObjectWithIdResultT() = default;
  InspectObjectWithIdResultT(const InspectObjectWithIdResultT &o);
  InspectObjectWithIdResultT(InspectObjectWithIdResultT&&) FLATBUFFERS_NOEXCEPT = default;
  InspectObjectWithIdResultT &operator=(InspectObjectWithIdResultT o) FLATBUFFERS_NOEXCEPT;
};

struct InspectObjectWithIdResult FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef InspectObjectWithIdResultT NativeTableType;
  typedef InspectObjectWithIdResultBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return InspectObjectWithIdResultTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_INFO = 4
  };
  const Gamium::Protocol::Types::ObjectInfo *info() const {
    return GetPointer<const Gamium::Protocol::Types::ObjectInfo *>(VT_INFO);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_INFO) &&
           verifier.VerifyTable(info()) &&
           verifier.EndTable();
  }
  InspectObjectWithIdResultT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(InspectObjectWithIdResultT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<InspectObjectWithIdResult> Pack(flatbuffers::FlatBufferBuilder &_fbb, const InspectObjectWithIdResultT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct InspectObjectWithIdResultBuilder {
  typedef InspectObjectWithIdResult Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_info(flatbuffers::Offset<Gamium::Protocol::Types::ObjectInfo> info) {
    fbb_.AddOffset(InspectObjectWithIdResult::VT_INFO, info);
  }
  explicit InspectObjectWithIdResultBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<InspectObjectWithIdResult> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<InspectObjectWithIdResult>(end);
    return o;
  }
};

inline flatbuffers::Offset<InspectObjectWithIdResult> CreateInspectObjectWithIdResult(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<Gamium::Protocol::Types::ObjectInfo> info = 0) {
  InspectObjectWithIdResultBuilder builder_(_fbb);
  builder_.add_info(info);
  return builder_.Finish();
}

flatbuffers::Offset<InspectObjectWithIdResult> CreateInspectObjectWithIdResult(flatbuffers::FlatBufferBuilder &_fbb, const InspectObjectWithIdResultT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct DumpObjectsHierarchyParamT : public flatbuffers::NativeTable {
  typedef DumpObjectsHierarchyParam TableType;
  std::string object_id{};
  uint32_t depth = 0;
};

struct DumpObjectsHierarchyParam FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef DumpObjectsHierarchyParamT NativeTableType;
  typedef DumpObjectsHierarchyParamBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return DumpObjectsHierarchyParamTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_OBJECT_ID = 4,
    VT_DEPTH = 6
  };
  const flatbuffers::String *object_id() const {
    return GetPointer<const flatbuffers::String *>(VT_OBJECT_ID);
  }
  uint32_t depth() const {
    return GetField<uint32_t>(VT_DEPTH, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_OBJECT_ID) &&
           verifier.VerifyString(object_id()) &&
           VerifyField<uint32_t>(verifier, VT_DEPTH, 4) &&
           verifier.EndTable();
  }
  DumpObjectsHierarchyParamT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(DumpObjectsHierarchyParamT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<DumpObjectsHierarchyParam> Pack(flatbuffers::FlatBufferBuilder &_fbb, const DumpObjectsHierarchyParamT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct DumpObjectsHierarchyParamBuilder {
  typedef DumpObjectsHierarchyParam Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_object_id(flatbuffers::Offset<flatbuffers::String> object_id) {
    fbb_.AddOffset(DumpObjectsHierarchyParam::VT_OBJECT_ID, object_id);
  }
  void add_depth(uint32_t depth) {
    fbb_.AddElement<uint32_t>(DumpObjectsHierarchyParam::VT_DEPTH, depth, 0);
  }
  explicit DumpObjectsHierarchyParamBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<DumpObjectsHierarchyParam> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<DumpObjectsHierarchyParam>(end);
    return o;
  }
};

inline flatbuffers::Offset<DumpObjectsHierarchyParam> CreateDumpObjectsHierarchyParam(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> object_id = 0,
    uint32_t depth = 0) {
  DumpObjectsHierarchyParamBuilder builder_(_fbb);
  builder_.add_depth(depth);
  builder_.add_object_id(object_id);
  return builder_.Finish();
}

flatbuffers::Offset<DumpObjectsHierarchyParam> CreateDumpObjectsHierarchyParam(flatbuffers::FlatBufferBuilder &_fbb, const DumpObjectsHierarchyParamT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct DumpObjectsHierarchyResultT : public flatbuffers::NativeTable {
  typedef DumpObjectsHierarchyResult TableType;
  std::vector<Gamium::Protocol::Types::ObjectsHierarchyT> hierarchies{};
};

struct DumpObjectsHierarchyResult FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef DumpObjectsHierarchyResultT NativeTableType;
  typedef DumpObjectsHierarchyResultBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return DumpObjectsHierarchyResultTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_HIERARCHIES = 4
  };
  const flatbuffers::Vector<flatbuffers::Offset<Gamium::Protocol::Types::ObjectsHierarchy>> *hierarchies() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<Gamium::Protocol::Types::ObjectsHierarchy>> *>(VT_HIERARCHIES);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_HIERARCHIES) &&
           verifier.VerifyVector(hierarchies()) &&
           verifier.VerifyVectorOfTables(hierarchies()) &&
           verifier.EndTable();
  }
  DumpObjectsHierarchyResultT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(DumpObjectsHierarchyResultT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<DumpObjectsHierarchyResult> Pack(flatbuffers::FlatBufferBuilder &_fbb, const DumpObjectsHierarchyResultT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct DumpObjectsHierarchyResultBuilder {
  typedef DumpObjectsHierarchyResult Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_hierarchies(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Gamium::Protocol::Types::ObjectsHierarchy>>> hierarchies) {
    fbb_.AddOffset(DumpObjectsHierarchyResult::VT_HIERARCHIES, hierarchies);
  }
  explicit DumpObjectsHierarchyResultBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<DumpObjectsHierarchyResult> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<DumpObjectsHierarchyResult>(end);
    return o;
  }
};

inline flatbuffers::Offset<DumpObjectsHierarchyResult> CreateDumpObjectsHierarchyResult(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Gamium::Protocol::Types::ObjectsHierarchy>>> hierarchies = 0) {
  DumpObjectsHierarchyResultBuilder builder_(_fbb);
  builder_.add_hierarchies(hierarchies);
  return builder_.Finish();
}

flatbuffers::Offset<DumpObjectsHierarchyResult> CreateDumpObjectsHierarchyResult(flatbuffers::FlatBufferBuilder &_fbb, const DumpObjectsHierarchyResultT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct GetPageSourceParamT : public flatbuffers::NativeTable {
  typedef GetPageSourceParam TableType;
};

struct GetPageSourceParam FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef GetPageSourceParamT NativeTableType;
  typedef GetPageSourceParamBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return GetPageSourceParamTypeTable();
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
  GetPageSourceParamT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(GetPageSourceParamT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<GetPageSourceParam> Pack(flatbuffers::FlatBufferBuilder &_fbb, const GetPageSourceParamT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct GetPageSourceParamBuilder {
  typedef GetPageSourceParam Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit GetPageSourceParamBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<GetPageSourceParam> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<GetPageSourceParam>(end);
    return o;
  }
};

inline flatbuffers::Offset<GetPageSourceParam> CreateGetPageSourceParam(
    flatbuffers::FlatBufferBuilder &_fbb) {
  GetPageSourceParamBuilder builder_(_fbb);
  return builder_.Finish();
}

flatbuffers::Offset<GetPageSourceParam> CreateGetPageSourceParam(flatbuffers::FlatBufferBuilder &_fbb, const GetPageSourceParamT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct GetPageSourceResultT : public flatbuffers::NativeTable {
  typedef GetPageSourceResult TableType;
  std::string page_source{};
};

struct GetPageSourceResult FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef GetPageSourceResultT NativeTableType;
  typedef GetPageSourceResultBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return GetPageSourceResultTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_PAGE_SOURCE = 4
  };
  const flatbuffers::String *page_source() const {
    return GetPointer<const flatbuffers::String *>(VT_PAGE_SOURCE);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_PAGE_SOURCE) &&
           verifier.VerifyString(page_source()) &&
           verifier.EndTable();
  }
  GetPageSourceResultT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(GetPageSourceResultT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<GetPageSourceResult> Pack(flatbuffers::FlatBufferBuilder &_fbb, const GetPageSourceResultT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct GetPageSourceResultBuilder {
  typedef GetPageSourceResult Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_page_source(flatbuffers::Offset<flatbuffers::String> page_source) {
    fbb_.AddOffset(GetPageSourceResult::VT_PAGE_SOURCE, page_source);
  }
  explicit GetPageSourceResultBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<GetPageSourceResult> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<GetPageSourceResult>(end);
    return o;
  }
};

inline flatbuffers::Offset<GetPageSourceResult> CreateGetPageSourceResult(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> page_source = 0) {
  GetPageSourceResultBuilder builder_(_fbb);
  builder_.add_page_source(page_source);
  return builder_.Finish();
}

flatbuffers::Offset<GetPageSourceResult> CreateGetPageSourceResult(flatbuffers::FlatBufferBuilder &_fbb, const GetPageSourceResultT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

inline InspectObjectOnScreenParamT::InspectObjectOnScreenParamT(const InspectObjectOnScreenParamT &o)
      : pos((o.pos) ? new Gamium::Protocol::Types::Vector2(*o.pos) : nullptr),
        screen_size((o.screen_size) ? new Gamium::Protocol::Types::Vector2(*o.screen_size) : nullptr) {
}

inline InspectObjectOnScreenParamT &InspectObjectOnScreenParamT::operator=(InspectObjectOnScreenParamT o) FLATBUFFERS_NOEXCEPT {
  std::swap(pos, o.pos);
  std::swap(screen_size, o.screen_size);
  return *this;
}

inline InspectObjectOnScreenParamT *InspectObjectOnScreenParam::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<InspectObjectOnScreenParamT>(new InspectObjectOnScreenParamT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void InspectObjectOnScreenParam::UnPackTo(InspectObjectOnScreenParamT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = pos(); if (_e) _o->pos = std::unique_ptr<Gamium::Protocol::Types::Vector2>(new Gamium::Protocol::Types::Vector2(*_e)); }
  { auto _e = screen_size(); if (_e) _o->screen_size = std::unique_ptr<Gamium::Protocol::Types::Vector2>(new Gamium::Protocol::Types::Vector2(*_e)); }
}

inline flatbuffers::Offset<InspectObjectOnScreenParam> InspectObjectOnScreenParam::Pack(flatbuffers::FlatBufferBuilder &_fbb, const InspectObjectOnScreenParamT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateInspectObjectOnScreenParam(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<InspectObjectOnScreenParam> CreateInspectObjectOnScreenParam(flatbuffers::FlatBufferBuilder &_fbb, const InspectObjectOnScreenParamT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const InspectObjectOnScreenParamT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _pos = _o->pos ? _o->pos.get() : nullptr;
  auto _screen_size = _o->screen_size ? _o->screen_size.get() : nullptr;
  return Gamium::Protocol::Packets::CreateInspectObjectOnScreenParam(
      _fbb,
      _pos,
      _screen_size);
}

inline InspectObjectOnScreenResultT::InspectObjectOnScreenResultT(const InspectObjectOnScreenResultT &o)
      : infos(o.infos),
        hit_point((o.hit_point) ? new Gamium::Protocol::Types::Vector3(*o.hit_point) : nullptr) {
}

inline InspectObjectOnScreenResultT &InspectObjectOnScreenResultT::operator=(InspectObjectOnScreenResultT o) FLATBUFFERS_NOEXCEPT {
  std::swap(infos, o.infos);
  std::swap(hit_point, o.hit_point);
  return *this;
}

inline InspectObjectOnScreenResultT *InspectObjectOnScreenResult::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<InspectObjectOnScreenResultT>(new InspectObjectOnScreenResultT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void InspectObjectOnScreenResult::UnPackTo(InspectObjectOnScreenResultT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = infos(); if (_e) { _o->infos.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->infos[_i] = *std::unique_ptr<Gamium::Protocol::Types::ObjectInfoT>(_e->Get(_i)->UnPack(_resolver)); } } else { _o->infos.resize(0); } }
  { auto _e = hit_point(); if (_e) _o->hit_point = std::unique_ptr<Gamium::Protocol::Types::Vector3>(new Gamium::Protocol::Types::Vector3(*_e)); }
}

inline flatbuffers::Offset<InspectObjectOnScreenResult> InspectObjectOnScreenResult::Pack(flatbuffers::FlatBufferBuilder &_fbb, const InspectObjectOnScreenResultT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateInspectObjectOnScreenResult(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<InspectObjectOnScreenResult> CreateInspectObjectOnScreenResult(flatbuffers::FlatBufferBuilder &_fbb, const InspectObjectOnScreenResultT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const InspectObjectOnScreenResultT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _infos = _fbb.CreateVector<flatbuffers::Offset<Gamium::Protocol::Types::ObjectInfo>> (_o->infos.size(), [](size_t i, _VectorArgs *__va) { return CreateObjectInfo(*__va->__fbb, &(__va->__o->infos[i]), __va->__rehasher); }, &_va );
  auto _hit_point = _o->hit_point ? _o->hit_point.get() : nullptr;
  return Gamium::Protocol::Packets::CreateInspectObjectOnScreenResult(
      _fbb,
      _infos,
      _hit_point);
}

inline InspectObjectWithIdParamT *InspectObjectWithIdParam::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<InspectObjectWithIdParamT>(new InspectObjectWithIdParamT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void InspectObjectWithIdParam::UnPackTo(InspectObjectWithIdParamT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = object_id(); if (_e) _o->object_id = _e->str(); }
}

inline flatbuffers::Offset<InspectObjectWithIdParam> InspectObjectWithIdParam::Pack(flatbuffers::FlatBufferBuilder &_fbb, const InspectObjectWithIdParamT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateInspectObjectWithIdParam(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<InspectObjectWithIdParam> CreateInspectObjectWithIdParam(flatbuffers::FlatBufferBuilder &_fbb, const InspectObjectWithIdParamT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const InspectObjectWithIdParamT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _object_id = _o->object_id.empty() ? _fbb.CreateSharedString("") : _fbb.CreateString(_o->object_id);
  return Gamium::Protocol::Packets::CreateInspectObjectWithIdParam(
      _fbb,
      _object_id);
}

inline InspectObjectWithIdResultT::InspectObjectWithIdResultT(const InspectObjectWithIdResultT &o)
      : info((o.info) ? new Gamium::Protocol::Types::ObjectInfoT(*o.info) : nullptr) {
}

inline InspectObjectWithIdResultT &InspectObjectWithIdResultT::operator=(InspectObjectWithIdResultT o) FLATBUFFERS_NOEXCEPT {
  std::swap(info, o.info);
  return *this;
}

inline InspectObjectWithIdResultT *InspectObjectWithIdResult::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<InspectObjectWithIdResultT>(new InspectObjectWithIdResultT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void InspectObjectWithIdResult::UnPackTo(InspectObjectWithIdResultT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = info(); if (_e) { if(_o->info) { _e->UnPackTo(_o->info.get(), _resolver); } else { _o->info = std::unique_ptr<Gamium::Protocol::Types::ObjectInfoT>(_e->UnPack(_resolver)); } } else if (_o->info) { _o->info.reset(); } }
}

inline flatbuffers::Offset<InspectObjectWithIdResult> InspectObjectWithIdResult::Pack(flatbuffers::FlatBufferBuilder &_fbb, const InspectObjectWithIdResultT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateInspectObjectWithIdResult(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<InspectObjectWithIdResult> CreateInspectObjectWithIdResult(flatbuffers::FlatBufferBuilder &_fbb, const InspectObjectWithIdResultT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const InspectObjectWithIdResultT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _info = _o->info ? CreateObjectInfo(_fbb, _o->info.get(), _rehasher) : 0;
  return Gamium::Protocol::Packets::CreateInspectObjectWithIdResult(
      _fbb,
      _info);
}

inline DumpObjectsHierarchyParamT *DumpObjectsHierarchyParam::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<DumpObjectsHierarchyParamT>(new DumpObjectsHierarchyParamT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void DumpObjectsHierarchyParam::UnPackTo(DumpObjectsHierarchyParamT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = object_id(); if (_e) _o->object_id = _e->str(); }
  { auto _e = depth(); _o->depth = _e; }
}

inline flatbuffers::Offset<DumpObjectsHierarchyParam> DumpObjectsHierarchyParam::Pack(flatbuffers::FlatBufferBuilder &_fbb, const DumpObjectsHierarchyParamT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateDumpObjectsHierarchyParam(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<DumpObjectsHierarchyParam> CreateDumpObjectsHierarchyParam(flatbuffers::FlatBufferBuilder &_fbb, const DumpObjectsHierarchyParamT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const DumpObjectsHierarchyParamT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _object_id = _o->object_id.empty() ? _fbb.CreateSharedString("") : _fbb.CreateString(_o->object_id);
  auto _depth = _o->depth;
  return Gamium::Protocol::Packets::CreateDumpObjectsHierarchyParam(
      _fbb,
      _object_id,
      _depth);
}

inline DumpObjectsHierarchyResultT *DumpObjectsHierarchyResult::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<DumpObjectsHierarchyResultT>(new DumpObjectsHierarchyResultT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void DumpObjectsHierarchyResult::UnPackTo(DumpObjectsHierarchyResultT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = hierarchies(); if (_e) { _o->hierarchies.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->hierarchies[_i] = *std::unique_ptr<Gamium::Protocol::Types::ObjectsHierarchyT>(_e->Get(_i)->UnPack(_resolver)); } } else { _o->hierarchies.resize(0); } }
}

inline flatbuffers::Offset<DumpObjectsHierarchyResult> DumpObjectsHierarchyResult::Pack(flatbuffers::FlatBufferBuilder &_fbb, const DumpObjectsHierarchyResultT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateDumpObjectsHierarchyResult(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<DumpObjectsHierarchyResult> CreateDumpObjectsHierarchyResult(flatbuffers::FlatBufferBuilder &_fbb, const DumpObjectsHierarchyResultT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const DumpObjectsHierarchyResultT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _hierarchies = _fbb.CreateVector<flatbuffers::Offset<Gamium::Protocol::Types::ObjectsHierarchy>> (_o->hierarchies.size(), [](size_t i, _VectorArgs *__va) { return CreateObjectsHierarchy(*__va->__fbb, &(__va->__o->hierarchies[i]), __va->__rehasher); }, &_va );
  return Gamium::Protocol::Packets::CreateDumpObjectsHierarchyResult(
      _fbb,
      _hierarchies);
}

inline GetPageSourceParamT *GetPageSourceParam::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<GetPageSourceParamT>(new GetPageSourceParamT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void GetPageSourceParam::UnPackTo(GetPageSourceParamT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
}

inline flatbuffers::Offset<GetPageSourceParam> GetPageSourceParam::Pack(flatbuffers::FlatBufferBuilder &_fbb, const GetPageSourceParamT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateGetPageSourceParam(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<GetPageSourceParam> CreateGetPageSourceParam(flatbuffers::FlatBufferBuilder &_fbb, const GetPageSourceParamT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const GetPageSourceParamT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  return Gamium::Protocol::Packets::CreateGetPageSourceParam(
      _fbb);
}

inline GetPageSourceResultT *GetPageSourceResult::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<GetPageSourceResultT>(new GetPageSourceResultT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void GetPageSourceResult::UnPackTo(GetPageSourceResultT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = page_source(); if (_e) _o->page_source = _e->str(); }
}

inline flatbuffers::Offset<GetPageSourceResult> GetPageSourceResult::Pack(flatbuffers::FlatBufferBuilder &_fbb, const GetPageSourceResultT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateGetPageSourceResult(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<GetPageSourceResult> CreateGetPageSourceResult(flatbuffers::FlatBufferBuilder &_fbb, const GetPageSourceResultT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const GetPageSourceResultT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _page_source = _o->page_source.empty() ? _fbb.CreateSharedString("") : _fbb.CreateString(_o->page_source);
  return Gamium::Protocol::Packets::CreateGetPageSourceResult(
      _fbb,
      _page_source);
}

inline const flatbuffers::TypeTable *InspectObjectOnScreenParamTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_SEQUENCE, 0, 0 },
    { flatbuffers::ET_SEQUENCE, 0, 0 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    Gamium::Protocol::Types::Vector2TypeTable
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 2, type_codes, type_refs, nullptr, nullptr, nullptr
  };
  return &tt;
}

inline const flatbuffers::TypeTable *InspectObjectOnScreenResultTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_SEQUENCE, 1, 0 },
    { flatbuffers::ET_SEQUENCE, 0, 1 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    Gamium::Protocol::Types::ObjectInfoTypeTable,
    Gamium::Protocol::Types::Vector3TypeTable
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 2, type_codes, type_refs, nullptr, nullptr, nullptr
  };
  return &tt;
}

inline const flatbuffers::TypeTable *InspectObjectWithIdParamTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_STRING, 0, -1 }
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 1, type_codes, nullptr, nullptr, nullptr, nullptr
  };
  return &tt;
}

inline const flatbuffers::TypeTable *InspectObjectWithIdResultTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_SEQUENCE, 0, 0 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    Gamium::Protocol::Types::ObjectInfoTypeTable
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 1, type_codes, type_refs, nullptr, nullptr, nullptr
  };
  return &tt;
}

inline const flatbuffers::TypeTable *DumpObjectsHierarchyParamTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_STRING, 0, -1 },
    { flatbuffers::ET_UINT, 0, -1 }
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 2, type_codes, nullptr, nullptr, nullptr, nullptr
  };
  return &tt;
}

inline const flatbuffers::TypeTable *DumpObjectsHierarchyResultTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_SEQUENCE, 1, 0 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    Gamium::Protocol::Types::ObjectsHierarchyTypeTable
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 1, type_codes, type_refs, nullptr, nullptr, nullptr
  };
  return &tt;
}

inline const flatbuffers::TypeTable *GetPageSourceParamTypeTable() {
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 0, nullptr, nullptr, nullptr, nullptr, nullptr
  };
  return &tt;
}

inline const flatbuffers::TypeTable *GetPageSourceResultTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_STRING, 0, -1 }
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 1, type_codes, nullptr, nullptr, nullptr, nullptr
  };
  return &tt;
}

}  // namespace Packets
}  // namespace Protocol
}  // namespace Gamium

#endif  // FLATBUFFERS_GENERATED_INSPECTORPACKET_GAMIUM_PROTOCOL_PACKETS_H_
