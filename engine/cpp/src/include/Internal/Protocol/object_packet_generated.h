// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_OBJECTPACKET_GAMIUM_PROTOCOL_PACKETS_H_
#define FLATBUFFERS_GENERATED_OBJECTPACKET_GAMIUM_PROTOCOL_PACKETS_H_

#include "flatbuffers/flatbuffers.h"

// Ensure the included flatbuffers.h is the same version as when this file was
// generated, otherwise it may not be compatible.
static_assert(FLATBUFFERS_VERSION_MAJOR == 22 &&
              FLATBUFFERS_VERSION_MINOR == 10 &&
              FLATBUFFERS_VERSION_REVISION == 26,
             "Non-compatible flatbuffers version included");

#include "object_generated.h"
#include "object_hierarchy_generated.h"
#include "vector_generated.h"

namespace Gamium {
namespace Protocol {
namespace Packets {

struct FindObjectsParam;
struct FindObjectsParamBuilder;
struct FindObjectsParamT;

struct FindObjectsResult;
struct FindObjectsResultBuilder;
struct FindObjectsResultT;

struct QueryObjectInteractableParam;
struct QueryObjectInteractableParamBuilder;
struct QueryObjectInteractableParamT;

struct QueryObjectInteractableResult;
struct QueryObjectInteractableResultBuilder;
struct QueryObjectInteractableResultT;

inline const flatbuffers::TypeTable *FindObjectsParamTypeTable();

inline const flatbuffers::TypeTable *FindObjectsResultTypeTable();

inline const flatbuffers::TypeTable *QueryObjectInteractableParamTypeTable();

inline const flatbuffers::TypeTable *QueryObjectInteractableResultTypeTable();

struct FindObjectsParamT : public flatbuffers::NativeTable {
  typedef FindObjectsParam TableType;
  std::unique_ptr<Gamium::Protocol::Types::ObjectLocatorT> locator{};
  FindObjectsParamT() = default;
  FindObjectsParamT(const FindObjectsParamT &o);
  FindObjectsParamT(FindObjectsParamT&&) FLATBUFFERS_NOEXCEPT = default;
  FindObjectsParamT &operator=(FindObjectsParamT o) FLATBUFFERS_NOEXCEPT;
};

struct FindObjectsParam FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef FindObjectsParamT NativeTableType;
  typedef FindObjectsParamBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return FindObjectsParamTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_LOCATOR = 4
  };
  const Gamium::Protocol::Types::ObjectLocator *locator() const {
    return GetPointer<const Gamium::Protocol::Types::ObjectLocator *>(VT_LOCATOR);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_LOCATOR) &&
           verifier.VerifyTable(locator()) &&
           verifier.EndTable();
  }
  FindObjectsParamT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(FindObjectsParamT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<FindObjectsParam> Pack(flatbuffers::FlatBufferBuilder &_fbb, const FindObjectsParamT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct FindObjectsParamBuilder {
  typedef FindObjectsParam Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_locator(flatbuffers::Offset<Gamium::Protocol::Types::ObjectLocator> locator) {
    fbb_.AddOffset(FindObjectsParam::VT_LOCATOR, locator);
  }
  explicit FindObjectsParamBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<FindObjectsParam> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<FindObjectsParam>(end);
    return o;
  }
};

inline flatbuffers::Offset<FindObjectsParam> CreateFindObjectsParam(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<Gamium::Protocol::Types::ObjectLocator> locator = 0) {
  FindObjectsParamBuilder builder_(_fbb);
  builder_.add_locator(locator);
  return builder_.Finish();
}

flatbuffers::Offset<FindObjectsParam> CreateFindObjectsParam(flatbuffers::FlatBufferBuilder &_fbb, const FindObjectsParamT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct FindObjectsResultT : public flatbuffers::NativeTable {
  typedef FindObjectsResult TableType;
  std::vector<Gamium::Protocol::Types::ObjectInfoT> infos{};
};

struct FindObjectsResult FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef FindObjectsResultT NativeTableType;
  typedef FindObjectsResultBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return FindObjectsResultTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_INFOS = 4
  };
  const flatbuffers::Vector<flatbuffers::Offset<Gamium::Protocol::Types::ObjectInfo>> *infos() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<Gamium::Protocol::Types::ObjectInfo>> *>(VT_INFOS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_INFOS) &&
           verifier.VerifyVector(infos()) &&
           verifier.VerifyVectorOfTables(infos()) &&
           verifier.EndTable();
  }
  FindObjectsResultT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(FindObjectsResultT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<FindObjectsResult> Pack(flatbuffers::FlatBufferBuilder &_fbb, const FindObjectsResultT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct FindObjectsResultBuilder {
  typedef FindObjectsResult Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_infos(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Gamium::Protocol::Types::ObjectInfo>>> infos) {
    fbb_.AddOffset(FindObjectsResult::VT_INFOS, infos);
  }
  explicit FindObjectsResultBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<FindObjectsResult> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<FindObjectsResult>(end);
    return o;
  }
};

inline flatbuffers::Offset<FindObjectsResult> CreateFindObjectsResult(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Gamium::Protocol::Types::ObjectInfo>>> infos = 0) {
  FindObjectsResultBuilder builder_(_fbb);
  builder_.add_infos(infos);
  return builder_.Finish();
}

flatbuffers::Offset<FindObjectsResult> CreateFindObjectsResult(flatbuffers::FlatBufferBuilder &_fbb, const FindObjectsResultT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct QueryObjectInteractableParamT : public flatbuffers::NativeTable {
  typedef QueryObjectInteractableParam TableType;
  std::string object_id{};
  bool check_moving = false;
  bool check_raycast = false;
};

struct QueryObjectInteractableParam FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef QueryObjectInteractableParamT NativeTableType;
  typedef QueryObjectInteractableParamBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return QueryObjectInteractableParamTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_OBJECT_ID = 4,
    VT_CHECK_MOVING = 6,
    VT_CHECK_RAYCAST = 8
  };
  const flatbuffers::String *object_id() const {
    return GetPointer<const flatbuffers::String *>(VT_OBJECT_ID);
  }
  bool check_moving() const {
    return GetField<uint8_t>(VT_CHECK_MOVING, 0) != 0;
  }
  bool check_raycast() const {
    return GetField<uint8_t>(VT_CHECK_RAYCAST, 0) != 0;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_OBJECT_ID) &&
           verifier.VerifyString(object_id()) &&
           VerifyField<uint8_t>(verifier, VT_CHECK_MOVING, 1) &&
           VerifyField<uint8_t>(verifier, VT_CHECK_RAYCAST, 1) &&
           verifier.EndTable();
  }
  QueryObjectInteractableParamT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(QueryObjectInteractableParamT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<QueryObjectInteractableParam> Pack(flatbuffers::FlatBufferBuilder &_fbb, const QueryObjectInteractableParamT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct QueryObjectInteractableParamBuilder {
  typedef QueryObjectInteractableParam Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_object_id(flatbuffers::Offset<flatbuffers::String> object_id) {
    fbb_.AddOffset(QueryObjectInteractableParam::VT_OBJECT_ID, object_id);
  }
  void add_check_moving(bool check_moving) {
    fbb_.AddElement<uint8_t>(QueryObjectInteractableParam::VT_CHECK_MOVING, static_cast<uint8_t>(check_moving), 0);
  }
  void add_check_raycast(bool check_raycast) {
    fbb_.AddElement<uint8_t>(QueryObjectInteractableParam::VT_CHECK_RAYCAST, static_cast<uint8_t>(check_raycast), 0);
  }
  explicit QueryObjectInteractableParamBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<QueryObjectInteractableParam> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<QueryObjectInteractableParam>(end);
    return o;
  }
};

inline flatbuffers::Offset<QueryObjectInteractableParam> CreateQueryObjectInteractableParam(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> object_id = 0,
    bool check_moving = false,
    bool check_raycast = false) {
  QueryObjectInteractableParamBuilder builder_(_fbb);
  builder_.add_object_id(object_id);
  builder_.add_check_raycast(check_raycast);
  builder_.add_check_moving(check_moving);
  return builder_.Finish();
}

flatbuffers::Offset<QueryObjectInteractableParam> CreateQueryObjectInteractableParam(flatbuffers::FlatBufferBuilder &_fbb, const QueryObjectInteractableParamT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct QueryObjectInteractableResultT : public flatbuffers::NativeTable {
  typedef QueryObjectInteractableResult TableType;
  bool is_interactable = false;
};

struct QueryObjectInteractableResult FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef QueryObjectInteractableResultT NativeTableType;
  typedef QueryObjectInteractableResultBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return QueryObjectInteractableResultTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_IS_INTERACTABLE = 4
  };
  bool is_interactable() const {
    return GetField<uint8_t>(VT_IS_INTERACTABLE, 0) != 0;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_IS_INTERACTABLE, 1) &&
           verifier.EndTable();
  }
  QueryObjectInteractableResultT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(QueryObjectInteractableResultT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<QueryObjectInteractableResult> Pack(flatbuffers::FlatBufferBuilder &_fbb, const QueryObjectInteractableResultT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct QueryObjectInteractableResultBuilder {
  typedef QueryObjectInteractableResult Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_is_interactable(bool is_interactable) {
    fbb_.AddElement<uint8_t>(QueryObjectInteractableResult::VT_IS_INTERACTABLE, static_cast<uint8_t>(is_interactable), 0);
  }
  explicit QueryObjectInteractableResultBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<QueryObjectInteractableResult> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<QueryObjectInteractableResult>(end);
    return o;
  }
};

inline flatbuffers::Offset<QueryObjectInteractableResult> CreateQueryObjectInteractableResult(
    flatbuffers::FlatBufferBuilder &_fbb,
    bool is_interactable = false) {
  QueryObjectInteractableResultBuilder builder_(_fbb);
  builder_.add_is_interactable(is_interactable);
  return builder_.Finish();
}

flatbuffers::Offset<QueryObjectInteractableResult> CreateQueryObjectInteractableResult(flatbuffers::FlatBufferBuilder &_fbb, const QueryObjectInteractableResultT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

inline FindObjectsParamT::FindObjectsParamT(const FindObjectsParamT &o)
      : locator((o.locator) ? new Gamium::Protocol::Types::ObjectLocatorT(*o.locator) : nullptr) {
}

inline FindObjectsParamT &FindObjectsParamT::operator=(FindObjectsParamT o) FLATBUFFERS_NOEXCEPT {
  std::swap(locator, o.locator);
  return *this;
}

inline FindObjectsParamT *FindObjectsParam::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<FindObjectsParamT>(new FindObjectsParamT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void FindObjectsParam::UnPackTo(FindObjectsParamT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = locator(); if (_e) { if(_o->locator) { _e->UnPackTo(_o->locator.get(), _resolver); } else { _o->locator = std::unique_ptr<Gamium::Protocol::Types::ObjectLocatorT>(_e->UnPack(_resolver)); } } else if (_o->locator) { _o->locator.reset(); } }
}

inline flatbuffers::Offset<FindObjectsParam> FindObjectsParam::Pack(flatbuffers::FlatBufferBuilder &_fbb, const FindObjectsParamT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateFindObjectsParam(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<FindObjectsParam> CreateFindObjectsParam(flatbuffers::FlatBufferBuilder &_fbb, const FindObjectsParamT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const FindObjectsParamT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _locator = _o->locator ? CreateObjectLocator(_fbb, _o->locator.get(), _rehasher) : 0;
  return Gamium::Protocol::Packets::CreateFindObjectsParam(
      _fbb,
      _locator);
}

inline FindObjectsResultT *FindObjectsResult::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<FindObjectsResultT>(new FindObjectsResultT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void FindObjectsResult::UnPackTo(FindObjectsResultT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = infos(); if (_e) { _o->infos.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->infos[_i] = *std::unique_ptr<Gamium::Protocol::Types::ObjectInfoT>(_e->Get(_i)->UnPack(_resolver)); } } else { _o->infos.resize(0); } }
}

inline flatbuffers::Offset<FindObjectsResult> FindObjectsResult::Pack(flatbuffers::FlatBufferBuilder &_fbb, const FindObjectsResultT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateFindObjectsResult(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<FindObjectsResult> CreateFindObjectsResult(flatbuffers::FlatBufferBuilder &_fbb, const FindObjectsResultT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const FindObjectsResultT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _infos = _fbb.CreateVector<flatbuffers::Offset<Gamium::Protocol::Types::ObjectInfo>> (_o->infos.size(), [](size_t i, _VectorArgs *__va) { return CreateObjectInfo(*__va->__fbb, &(__va->__o->infos[i]), __va->__rehasher); }, &_va );
  return Gamium::Protocol::Packets::CreateFindObjectsResult(
      _fbb,
      _infos);
}

inline QueryObjectInteractableParamT *QueryObjectInteractableParam::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<QueryObjectInteractableParamT>(new QueryObjectInteractableParamT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void QueryObjectInteractableParam::UnPackTo(QueryObjectInteractableParamT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = object_id(); if (_e) _o->object_id = _e->str(); }
  { auto _e = check_moving(); _o->check_moving = _e; }
  { auto _e = check_raycast(); _o->check_raycast = _e; }
}

inline flatbuffers::Offset<QueryObjectInteractableParam> QueryObjectInteractableParam::Pack(flatbuffers::FlatBufferBuilder &_fbb, const QueryObjectInteractableParamT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateQueryObjectInteractableParam(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<QueryObjectInteractableParam> CreateQueryObjectInteractableParam(flatbuffers::FlatBufferBuilder &_fbb, const QueryObjectInteractableParamT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const QueryObjectInteractableParamT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _object_id = _o->object_id.empty() ? _fbb.CreateSharedString("") : _fbb.CreateString(_o->object_id);
  auto _check_moving = _o->check_moving;
  auto _check_raycast = _o->check_raycast;
  return Gamium::Protocol::Packets::CreateQueryObjectInteractableParam(
      _fbb,
      _object_id,
      _check_moving,
      _check_raycast);
}

inline QueryObjectInteractableResultT *QueryObjectInteractableResult::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<QueryObjectInteractableResultT>(new QueryObjectInteractableResultT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void QueryObjectInteractableResult::UnPackTo(QueryObjectInteractableResultT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = is_interactable(); _o->is_interactable = _e; }
}

inline flatbuffers::Offset<QueryObjectInteractableResult> QueryObjectInteractableResult::Pack(flatbuffers::FlatBufferBuilder &_fbb, const QueryObjectInteractableResultT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateQueryObjectInteractableResult(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<QueryObjectInteractableResult> CreateQueryObjectInteractableResult(flatbuffers::FlatBufferBuilder &_fbb, const QueryObjectInteractableResultT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const QueryObjectInteractableResultT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _is_interactable = _o->is_interactable;
  return Gamium::Protocol::Packets::CreateQueryObjectInteractableResult(
      _fbb,
      _is_interactable);
}

inline const flatbuffers::TypeTable *FindObjectsParamTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_SEQUENCE, 0, 0 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    Gamium::Protocol::Types::ObjectLocatorTypeTable
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 1, type_codes, type_refs, nullptr, nullptr, nullptr
  };
  return &tt;
}

inline const flatbuffers::TypeTable *FindObjectsResultTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_SEQUENCE, 1, 0 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    Gamium::Protocol::Types::ObjectInfoTypeTable
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 1, type_codes, type_refs, nullptr, nullptr, nullptr
  };
  return &tt;
}

inline const flatbuffers::TypeTable *QueryObjectInteractableParamTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_STRING, 0, -1 },
    { flatbuffers::ET_BOOL, 0, -1 },
    { flatbuffers::ET_BOOL, 0, -1 }
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 3, type_codes, nullptr, nullptr, nullptr, nullptr
  };
  return &tt;
}

inline const flatbuffers::TypeTable *QueryObjectInteractableResultTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_BOOL, 0, -1 }
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 1, type_codes, nullptr, nullptr, nullptr, nullptr
  };
  return &tt;
}

}  // namespace Packets
}  // namespace Protocol
}  // namespace Gamium

#endif  // FLATBUFFERS_GENERATED_OBJECTPACKET_GAMIUM_PROTOCOL_PACKETS_H_
