// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_EXECUTE_GAMIUM_PROTOCOL_TYPES_H_
#define FLATBUFFERS_GENERATED_EXECUTE_GAMIUM_PROTOCOL_TYPES_H_

#include "flatbuffers/flatbuffers.h"

// Ensure the included flatbuffers.h is the same version as when this file was
// generated, otherwise it may not be compatible.
static_assert(FLATBUFFERS_VERSION_MAJOR == 22 &&
              FLATBUFFERS_VERSION_MINOR == 10 &&
              FLATBUFFERS_VERSION_REVISION == 26,
             "Non-compatible flatbuffers version included");

namespace Gamium {
namespace Protocol {
namespace Types {

enum class ExecuteRpcBy : int16_t {
  Method = 0,
  Field = 1,
  Property = 2,
  MIN = Method,
  MAX = Property
};

inline const ExecuteRpcBy (&EnumValuesExecuteRpcBy())[3] {
  static const ExecuteRpcBy values[] = {
    ExecuteRpcBy::Method,
    ExecuteRpcBy::Field,
    ExecuteRpcBy::Property
  };
  return values;
}

inline const char * const *EnumNamesExecuteRpcBy() {
  static const char * const names[4] = {
    "Method",
    "Field",
    "Property",
    nullptr
  };
  return names;
}

inline const char *EnumNameExecuteRpcBy(ExecuteRpcBy e) {
  if (flatbuffers::IsOutRange(e, ExecuteRpcBy::Method, ExecuteRpcBy::Property)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesExecuteRpcBy()[index];
}

inline const flatbuffers::TypeTable *ExecuteRpcByTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_SHORT, 0, 0 },
    { flatbuffers::ET_SHORT, 0, 0 },
    { flatbuffers::ET_SHORT, 0, 0 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    Gamium::Protocol::Types::ExecuteRpcByTypeTable
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_ENUM, 3, type_codes, type_refs, nullptr, nullptr, nullptr
  };
  return &tt;
}

}  // namespace Types
}  // namespace Protocol
}  // namespace Gamium

#endif  // FLATBUFFERS_GENERATED_EXECUTE_GAMIUM_PROTOCOL_TYPES_H_
