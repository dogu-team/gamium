// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_CONFIG_GAMIUM_PROTOCOL_TYPES_H_
#define FLATBUFFERS_GENERATED_CONFIG_GAMIUM_PROTOCOL_TYPES_H_

#include "flatbuffers/flatbuffers.h"

// Ensure the included flatbuffers.h is the same version as when this file was
// generated, otherwise it may not be compatible.
static_assert(FLATBUFFERS_VERSION_MAJOR == 22 &&
              FLATBUFFERS_VERSION_MINOR == 10 &&
              FLATBUFFERS_VERSION_REVISION == 26,
             "Non-compatible flatbuffers version included");

namespace Gamium {
namespace Protocol {
namespace Types {

struct Configuration;
struct ConfigurationBuilder;
struct ConfigurationT;

inline const flatbuffers::TypeTable *ConfigurationTypeTable();

struct ConfigurationT : public flatbuffers::NativeTable {
  typedef Configuration TableType;
  flatbuffers::Optional<bool> show_debug_ui = flatbuffers::nullopt;
  flatbuffers::Optional<bool> inspect_ignore_big_object = flatbuffers::nullopt;
};

struct Configuration FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ConfigurationT NativeTableType;
  typedef ConfigurationBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return ConfigurationTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_SHOW_DEBUG_UI = 4,
    VT_INSPECT_IGNORE_BIG_OBJECT = 6
  };
  flatbuffers::Optional<bool> show_debug_ui() const {
    return GetOptional<uint8_t, bool>(VT_SHOW_DEBUG_UI);
  }
  flatbuffers::Optional<bool> inspect_ignore_big_object() const {
    return GetOptional<uint8_t, bool>(VT_INSPECT_IGNORE_BIG_OBJECT);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_SHOW_DEBUG_UI, 1) &&
           VerifyField<uint8_t>(verifier, VT_INSPECT_IGNORE_BIG_OBJECT, 1) &&
           verifier.EndTable();
  }
  ConfigurationT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(ConfigurationT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Configuration> Pack(flatbuffers::FlatBufferBuilder &_fbb, const ConfigurationT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct ConfigurationBuilder {
  typedef Configuration Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_show_debug_ui(bool show_debug_ui) {
    fbb_.AddElement<uint8_t>(Configuration::VT_SHOW_DEBUG_UI, static_cast<uint8_t>(show_debug_ui));
  }
  void add_inspect_ignore_big_object(bool inspect_ignore_big_object) {
    fbb_.AddElement<uint8_t>(Configuration::VT_INSPECT_IGNORE_BIG_OBJECT, static_cast<uint8_t>(inspect_ignore_big_object));
  }
  explicit ConfigurationBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Configuration> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Configuration>(end);
    return o;
  }
};

inline flatbuffers::Offset<Configuration> CreateConfiguration(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Optional<bool> show_debug_ui = flatbuffers::nullopt,
    flatbuffers::Optional<bool> inspect_ignore_big_object = flatbuffers::nullopt) {
  ConfigurationBuilder builder_(_fbb);
  if(inspect_ignore_big_object) { builder_.add_inspect_ignore_big_object(*inspect_ignore_big_object); }
  if(show_debug_ui) { builder_.add_show_debug_ui(*show_debug_ui); }
  return builder_.Finish();
}

flatbuffers::Offset<Configuration> CreateConfiguration(flatbuffers::FlatBufferBuilder &_fbb, const ConfigurationT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

inline ConfigurationT *Configuration::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<ConfigurationT>(new ConfigurationT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void Configuration::UnPackTo(ConfigurationT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = show_debug_ui(); _o->show_debug_ui = _e; }
  { auto _e = inspect_ignore_big_object(); _o->inspect_ignore_big_object = _e; }
}

inline flatbuffers::Offset<Configuration> Configuration::Pack(flatbuffers::FlatBufferBuilder &_fbb, const ConfigurationT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateConfiguration(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Configuration> CreateConfiguration(flatbuffers::FlatBufferBuilder &_fbb, const ConfigurationT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const ConfigurationT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _show_debug_ui = _o->show_debug_ui;
  auto _inspect_ignore_big_object = _o->inspect_ignore_big_object;
  return Gamium::Protocol::Types::CreateConfiguration(
      _fbb,
      _show_debug_ui,
      _inspect_ignore_big_object);
}

inline const flatbuffers::TypeTable *ConfigurationTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_BOOL, 0, -1 },
    { flatbuffers::ET_BOOL, 0, -1 }
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 2, type_codes, nullptr, nullptr, nullptr, nullptr
  };
  return &tt;
}

}  // namespace Types
}  // namespace Protocol
}  // namespace Gamium

#endif  // FLATBUFFERS_GENERATED_CONFIG_GAMIUM_PROTOCOL_TYPES_H_
